{"ast":null,"code":"import { constants } from \"../Generator/ECGTypes\";\nimport { copy } from \"./utility\";\n\nconst generateSignal = leadDetails => {\n  // add each event to the signal\n  const addEventToSignal = (signal, [event, axisFactor]) => {\n    let start = Math.floor(event.parameters.start);\n\n    for (const [_, settings] of Object.entries(event.parameters.waves)) {\n      const {\n        radius\n      } = settings;\n      const waveEnd = Math.min(constants.sampleCount, start + 2 * radius);\n      const firstIndex = Math.max(0, start); // as 'i' refers to an idx (up to 5000), subtracting \n      // 'waveStart' and 'radius' sets the center of the wave as 0\n\n      for (let i = firstIndex; i < waveEnd; i++) {\n        signal[i][0] += axisFactor * bump(i - start - radius, settings);\n        signal[i][1] = event.information.length !== 0;\n      }\n    }\n\n    return signal;\n  }; // convert lead (event series) to a one dimensional ECG signal\n  // we combine axis factor with event for convenience\n\n\n  const renderLead = lead => {\n    const {\n      events,\n      startIdx,\n      sampleCount,\n      axisFactor\n    } = leadDetails.find(ld => ld.lead === lead);\n    const eventAndAxisList = events.map(e => [e, axisFactor]);\n    return eventAndAxisList.reduce(addEventToSignal, copy(constants.noisySignal)).slice(startIdx, startIdx + sampleCount);\n  };\n\n  const renderRow = row => {\n    return row.map(renderLead).flat();\n  };\n\n  return constants.signalStructure.map(renderRow);\n}; // determine magnitude of depolarisation (gaussian), center of the wave is pos === 0\n\n\nconst bump = (pos, {\n  mag,\n  upstroke,\n  kurtosis\n}) => {\n  const yScale = mag + (pos < 0 ? 0 : upstroke);\n  const yTranslation = pos < 0 ? upstroke : 0;\n  return yScale * Math.pow(Math.E, -1 * Math.pow(kurtosis * pos, 2)) + yTranslation;\n};\n\nexport default generateSignal;","map":{"version":3,"sources":["/Users/albert/projects/med-bakery-react/client/src/components/ECGPage/Functions/renderLead.tsx"],"names":["constants","copy","generateSignal","leadDetails","addEventToSignal","signal","event","axisFactor","start","Math","floor","parameters","_","settings","Object","entries","waves","radius","waveEnd","min","sampleCount","firstIndex","max","i","bump","information","length","renderLead","lead","events","startIdx","find","ld","eventAndAxisList","map","e","reduce","noisySignal","slice","renderRow","row","flat","signalStructure","pos","mag","upstroke","kurtosis","yScale","yTranslation","pow","E"],"mappings":"AAAA,SAA6CA,SAA7C,QAAwF,uBAAxF;AACA,SAASC,IAAT,QAAqB,WAArB;;AAEA,MAAMC,cAAc,GAAIC,WAAD,IAA2C;AAE9D;AACA,QAAMC,gBAAgB,GAAG,CAACC,MAAD,EAAiB,CAACC,KAAD,EAAQC,UAAR,CAAjB,KAAqE;AAC1F,QAAIC,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWJ,KAAK,CAACK,UAAN,CAAiBH,KAA5B,CAAZ;;AAEA,SAAK,MAAM,CAACI,CAAD,EAAIC,QAAJ,CAAX,IAA4BC,MAAM,CAACC,OAAP,CAAeT,KAAK,CAACK,UAAN,CAAiBK,KAAhC,CAA5B,EAAoE;AAChE,YAAM;AAAEC,QAAAA;AAAF,UAAaJ,QAAnB;AACA,YAAMK,OAAO,GAAGT,IAAI,CAACU,GAAL,CAASnB,SAAS,CAACoB,WAAnB,EAAgCZ,KAAK,GAAG,IAAIS,MAA5C,CAAhB;AACA,YAAMI,UAAU,GAAGZ,IAAI,CAACa,GAAL,CAAS,CAAT,EAAYd,KAAZ,CAAnB,CAHgE,CAKhE;AACA;;AACA,WAAI,IAAIe,CAAC,GAAGF,UAAZ,EAAwBE,CAAC,GAAGL,OAA5B,EAAqCK,CAAC,EAAtC,EAA0C;AACtClB,QAAAA,MAAM,CAACkB,CAAD,CAAN,CAAU,CAAV,KAAgBhB,UAAU,GAAGiB,IAAI,CAACD,CAAC,GAAGf,KAAJ,GAAYS,MAAb,EAAqBJ,QAArB,CAAjC;AACAR,QAAAA,MAAM,CAACkB,CAAD,CAAN,CAAU,CAAV,IAAejB,KAAK,CAACmB,WAAN,CAAkBC,MAAlB,KAA6B,CAA5C;AACH;AACJ;;AAED,WAAOrB,MAAP;AACH,GAjBD,CAH8D,CAsB9D;AACA;;;AACA,QAAMsB,UAAU,GAAIC,IAAD,IAAwB;AACvC,UAAM;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,QAAV;AAAoBV,MAAAA,WAApB;AAAiCb,MAAAA;AAAjC,QAAgDJ,WAAW,CAAC4B,IAAZ,CAAiBC,EAAE,IAAIA,EAAE,CAACJ,IAAH,KAAYA,IAAnC,CAAtD;AACA,UAAMK,gBAAsC,GAAGJ,MAAM,CAACK,GAAP,CAAWC,CAAC,IAAI,CAACA,CAAD,EAAI5B,UAAJ,CAAhB,CAA/C;AACA,WAAO0B,gBAAgB,CAACG,MAAjB,CAAwBhC,gBAAxB,EAA0CH,IAAI,CAACD,SAAS,CAACqC,WAAX,CAA9C,EAAuEC,KAAvE,CAA6ER,QAA7E,EAAuFA,QAAQ,GAAGV,WAAlG,CAAP;AACH,GAJD;;AAMA,QAAMmB,SAAS,GAAIC,GAAD,IAAyB;AACvC,WAAOA,GAAG,CAACN,GAAJ,CAAQP,UAAR,EAAoBc,IAApB,EAAP;AACH,GAFD;;AAIA,SAAOzC,SAAS,CAAC0C,eAAV,CAA0BR,GAA1B,CAA8BK,SAA9B,CAAP;AACH,CAnCD,C,CAsCA;;;AACA,MAAMf,IAAI,GAAG,CAACmB,GAAD,EAAc;AAAEC,EAAAA,GAAF;AAAOC,EAAAA,QAAP;AAAiBC,EAAAA;AAAjB,CAAd,KAAoE;AAC7E,QAAMC,MAAM,GAASH,GAAG,IAAID,GAAG,GAAG,CAAN,GAAU,CAAV,GAAcE,QAAlB,CAAxB;AACA,QAAMG,YAAY,GAAGL,GAAG,GAAG,CAAN,GAAUE,QAAV,GAAqB,CAA1C;AACA,SAAOE,MAAM,GAAGtC,IAAI,CAACwC,GAAL,CAASxC,IAAI,CAACyC,CAAd,EAAiB,CAAC,CAAD,GAAMzC,IAAI,CAACwC,GAAL,CAASH,QAAQ,GAAGH,GAApB,EAAyB,CAAzB,CAAvB,CAAT,GAAgEK,YAAvE;AACH,CAJD;;AAMA,eAAe9C,cAAf","sourcesContent":["import { WaveSettings, LeadDetail, EcgEvent, constants, Lead, Signal, FourSignal } from \"../Generator/ECGTypes\";\nimport { copy } from \"./utility\";\n\nconst generateSignal = (leadDetails: LeadDetail[]): FourSignal => {\n\n    // add each event to the signal\n    const addEventToSignal = (signal: Signal, [event, axisFactor]: [EcgEvent, number]): Signal => {\n        let start = Math.floor(event.parameters.start);\n\n        for (const [_, settings] of Object.entries(event.parameters.waves)) {\n            const { radius } = settings;\n            const waveEnd = Math.min(constants.sampleCount, start + 2 * radius);\n            const firstIndex = Math.max(0, start);\n\n            // as 'i' refers to an idx (up to 5000), subtracting \n            // 'waveStart' and 'radius' sets the center of the wave as 0\n            for(let i = firstIndex; i < waveEnd; i++) {                          \n                signal[i][0] += axisFactor * bump(i - start - radius, settings); \n                signal[i][1] = event.information.length !== 0;    \n            }\n        }\n\n        return signal;\n    }\n\n    // convert lead (event series) to a one dimensional ECG signal\n    // we combine axis factor with event for convenience\n    const renderLead = (lead: Lead): Signal => {\n        const { events, startIdx, sampleCount, axisFactor } = leadDetails.find(ld => ld.lead === lead)!;\n        const eventAndAxisList: [EcgEvent, number][] = events.map(e => [e, axisFactor]);\n        return eventAndAxisList.reduce(addEventToSignal, copy(constants.noisySignal)).slice(startIdx, startIdx + sampleCount);\n    }\n    \n    const renderRow = (row: Lead[]): Signal => {\n        return row.map(renderLead).flat()\n    }\n\n    return constants.signalStructure.map(renderRow);\n}\n\n\n// determine magnitude of depolarisation (gaussian), center of the wave is pos === 0\nconst bump = (pos: number, { mag, upstroke, kurtosis }: WaveSettings): number => {\n    const yScale       = mag + (pos < 0 ? 0 : upstroke);\n    const yTranslation = pos < 0 ? upstroke : 0;\n    return yScale * Math.pow(Math.E, -1 * (Math.pow(kurtosis * pos, 2))) + yTranslation;\n}\n\nexport default generateSignal;"]},"metadata":{},"sourceType":"module"}