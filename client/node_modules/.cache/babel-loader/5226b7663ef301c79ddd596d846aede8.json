{"ast":null,"code":"import { retrieveDiagnoses } from \"./ECGDiagnoses\";\nimport { constants } from \"./ECGTypes\";\nimport { qualifyAxis, randomVal, qualifyHR, copy, reduceObj } from \"../Functions/utility\";\nimport getPointsOfInterest from \"../Functions/getPointsOfInterest\";\nimport generateSignal from \"../Functions/renderLead\"; //    Steps to ecg generation\n//\n// 1. Diagnosis is retrieved from predefine list (./ECGDiagnoses) with\n//    specific topcis used for filtering.\n//\n// 2. The data within the diagnosis is used to convert lead constants to\n//    lead details (add EcgEvents and axis factors). An EcgEven is simply\n//    a complete set of 'pqrst' wave parameters with metadata concerning \n//    pathology.\n//\n// 3. The process of event creation (createEvent) entails iterating through\n//    the waveform changes stipulated by the diagnosis and accumlating them\n//    with the initial waveform parameters (addWaves).\n//\n// 4. We aslo accumulate metadata concerning pathological wavechanges (e.g\n//    st-elevation, pr prolongation) in the 'information' section of the\n//    event. We use predicates to determine which events to add to.\n//\n// 5. Once detail generation is complete (events and axisFactors added),\n//    they may be used to generate the actual ECG signal as well as \n//    determine the locations of Points of interest (ECG events with  \n//    pathological metadata)\n\nexport const generateECG = topics => {\n  const diagnosis = retrieveDiagnoses(topics);\n  const leadDetails = generateLeadDetails(diagnosis);\n  const {\n    rateOptions,\n    rhythmOptions,\n    axisOptions,\n    diagnosisOptions\n  } = constants;\n  return {\n    signal: generateSignal(leadDetails),\n    pointsOfInterest: getPointsOfInterest(leadDetails),\n    explanation: diagnosis.explanation,\n    answered: false,\n    sections: [{\n      label: \"Rate\",\n      correct: qualifyHR(diagnosis.rate),\n      selected: \"\",\n      options: rateOptions\n    }, {\n      label: \"Rhythm\",\n      correct: diagnosis.rhythm,\n      selected: \"\",\n      options: rhythmOptions\n    }, {\n      label: \"Axis\",\n      correct: qualifyAxis(diagnosis.axis),\n      selected: \"\",\n      options: axisOptions\n    }, {\n      label: \"Diagnosis\",\n      correct: diagnosis.diagnosis,\n      selected: \"\",\n      options: diagnosisOptions\n    }]\n  };\n};\n\nconst generateLeadDetails = diagnosis => {\n  // these are the 'baseline' parameters to which changes (within diagnois) will be added\n  const initialParameters = {\n    p: {\n      radius: randomVal(20, 50),\n      mag: randomVal(2, 10),\n      upstroke: 0.1,\n      kurtosis: 0.1\n    },\n    pr: {\n      radius: randomVal(1, 3),\n      mag: 0,\n      upstroke: 0.1,\n      kurtosis: 0.1\n    },\n    r: {\n      radius: randomVal(5, 10),\n      mag: randomVal(20, 50),\n      upstroke: 0.1,\n      kurtosis: 0.1\n    },\n    t: {\n      radius: randomVal(30, 80),\n      mag: randomVal(5, 15),\n      upstroke: 0.1,\n      kurtosis: 0.06\n    }\n  };\n\n  const createEvent = (lead, eventIdx) => {\n    // check if lead and eventIdx match with the given predicate\n    const matchPredicate = predicate => [predicate.kind === \"startRepeat\" && (eventIdx - predicate.start) % predicate.repeat === 0, predicate.kind === \"lead\" && predicate.leads.includes(lead), predicate.kind === \"index\" && eventIdx === predicate.index, predicate.kind === \"all\"].some(p => p); // add changes from diagnosis (start, waveform changes and pathology info) \n    // if predicate matches\n\n\n    const addChanges = (event, change) => {\n      if (!change.predicates.map(matchPredicate).every(p => p)) return event;\n      const information = event.information.concat(change.information);\n      const start = event.parameters.start + change.parameters.start;\n      const waves = reduceObj(addWaves, event.parameters.waves, change.parameters.waves);\n      return {\n        information,\n        parameters: {\n          start,\n          waves\n        }\n      };\n    }; // determine where the event begins (out of 5000) and copy inital parameters\n\n\n    const start = eventIdx * constants.sampleCount / Math.floor(diagnosis.rate / 6);\n    const event = {\n      information: [],\n      parameters: {\n        start,\n        waves: copy(initialParameters)\n      }\n    };\n    return diagnosis.changes.reduce(addChanges, event);\n  }; // add events and axis factors to each lead\n\n\n  const constantToDetail = leadConstant => {\n    const eventCount = Math.floor(diagnosis.rate / 6); // each ECG strip is 10s long\n\n    const events = Array(eventCount).fill(leadConstant.lead).map(createEvent);\n    const axisFactor = Math.cos((leadConstant.phase - 80) * (22 / 7) / 180);\n    return { ...leadConstant,\n      events,\n      axisFactor\n    };\n  };\n\n  return constants.leadConstants.map(constantToDetail);\n};\n\nconst addWaves = (waves, [waveLetter, settings]) => {\n  for (const [setting, value] of Object.entries(settings)) {\n    waves[waveLetter][setting] *= value;\n  }\n\n  return waves;\n};","map":{"version":3,"sources":["/Users/albert/projects/med-bakery-react/client/src/components/ECGPage/Generator/ECGGenerator.tsx"],"names":["retrieveDiagnoses","constants","qualifyAxis","randomVal","qualifyHR","copy","reduceObj","getPointsOfInterest","generateSignal","generateECG","topics","diagnosis","leadDetails","generateLeadDetails","rateOptions","rhythmOptions","axisOptions","diagnosisOptions","signal","pointsOfInterest","explanation","answered","sections","label","correct","rate","selected","options","rhythm","axis","initialParameters","p","radius","mag","upstroke","kurtosis","pr","r","t","createEvent","lead","eventIdx","matchPredicate","predicate","kind","start","repeat","leads","includes","index","some","addChanges","event","change","predicates","map","every","information","concat","parameters","waves","addWaves","sampleCount","Math","floor","changes","reduce","constantToDetail","leadConstant","eventCount","events","Array","fill","axisFactor","cos","phase","leadConstants","waveLetter","settings","setting","value","Object","entries"],"mappings":"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","sourcesContent":["import { retrieveDiagnoses } from \"./ECGDiagnoses\";\nimport { EcgEvent, EcgTopic, Lead, Predicate, WaveParameters, WaveParameterEntry, EcgQuestion, constants, LeadDetail, LeadConstant, Change, FirmDiagnosis, WaveSettingsEntry, SettingName } from \"./ECGTypes\";\nimport { qualifyAxis, randomVal, qualifyHR, copy, reduceObj } from \"../Functions/utility\";\nimport getPointsOfInterest from \"../Functions/getPointsOfInterest\";\nimport generateSignal from \"../Functions/renderLead\";\n\n//    Steps to ecg generation\n//\n// 1. Diagnosis is retrieved from predefine list (./ECGDiagnoses) with\n//    specific topcis used for filtering.\n//\n// 2. The data within the diagnosis is used to convert lead constants to\n//    lead details (add EcgEvents and axis factors). An EcgEven is simply\n//    a complete set of 'pqrst' wave parameters with metadata concerning \n//    pathology.\n//\n// 3. The process of event creation (createEvent) entails iterating through\n//    the waveform changes stipulated by the diagnosis and accumlating them\n//    with the initial waveform parameters (addWaves).\n//\n// 4. We aslo accumulate metadata concerning pathological wavechanges (e.g\n//    st-elevation, pr prolongation) in the 'information' section of the\n//    event. We use predicates to determine which events to add to.\n//\n// 5. Once detail generation is complete (events and axisFactors added),\n//    they may be used to generate the actual ECG signal as well as \n//    determine the locations of Points of interest (ECG events with  \n//    pathological metadata)\n\n\nexport const generateECG = (topics: EcgTopic[]): EcgQuestion => {\n\n    const diagnosis = retrieveDiagnoses(topics);\n    const leadDetails = generateLeadDetails(diagnosis);\n    const { rateOptions, rhythmOptions, axisOptions, diagnosisOptions } = constants;\n\n    return {\n        signal: generateSignal(leadDetails),\n        pointsOfInterest: getPointsOfInterest(leadDetails),\n        explanation: diagnosis.explanation,\n        answered: false,\n        sections: [\n            { label: \"Rate\",      correct: qualifyHR(diagnosis.rate),   selected: \"\", options: rateOptions },\n            { label: \"Rhythm\",    correct: diagnosis.rhythm,            selected: \"\", options: rhythmOptions },\n            { label: \"Axis\",      correct: qualifyAxis(diagnosis.axis), selected: \"\", options: axisOptions },\n            { label: \"Diagnosis\", correct: diagnosis.diagnosis,         selected: \"\", options: diagnosisOptions }\n        ]\n    }\n}\n\nconst generateLeadDetails = (diagnosis: FirmDiagnosis): LeadDetail[] => {\n\n    // these are the 'baseline' parameters to which changes (within diagnois) will be added\n    const initialParameters = {\n        p:  { radius: randomVal(20, 50), mag: randomVal(2, 10),  upstroke: 0.1, kurtosis: 0.1 },\n        pr: { radius: randomVal(1, 3),   mag: 0,                 upstroke: 0.1, kurtosis: 0.1 },\n        r:  { radius: randomVal(5, 10),  mag: randomVal(20, 50), upstroke: 0.1, kurtosis: 0.1 },\n        t:  { radius: randomVal(30, 80), mag: randomVal(5, 15),  upstroke: 0.1, kurtosis: 0.06 }\n    };\n\n    const createEvent = (lead: Lead, eventIdx: number): EcgEvent => {\n\n        // check if lead and eventIdx match with the given predicate\n        const matchPredicate = (predicate: Predicate) => [\n            predicate.kind === \"startRepeat\" && ((eventIdx - predicate.start) % predicate.repeat) === 0,\n            predicate.kind === \"lead\"        && predicate.leads.includes(lead),\n            predicate.kind === \"index\"       && eventIdx === predicate.index,\n            predicate.kind === \"all\"  \n        ].some(p => p);\n\n        // add changes from diagnosis (start, waveform changes and pathology info) \n        // if predicate matches\n        const addChanges = (event: EcgEvent, change: Change) => {\n            if (!change.predicates.map(matchPredicate).every(p => p)) return event;\n            const information = event.information.concat(change.information);\n            const start = event.parameters.start + change.parameters.start;\n            const waves = reduceObj(addWaves, event.parameters.waves, change.parameters.waves);\n            return { information, parameters: { start, waves } }\n        }\n\n        // determine where the event begins (out of 5000) and copy inital parameters\n        const start = eventIdx * constants.sampleCount / Math.floor(diagnosis.rate / 6);\n        const event: EcgEvent = { information: [], parameters: { start, waves: copy(initialParameters) } };\n\n        return diagnosis.changes.reduce(addChanges, event);\n    }\n\n    // add events and axis factors to each lead\n    const constantToDetail = (leadConstant: LeadConstant): LeadDetail => {\n        const eventCount = Math.floor(diagnosis.rate / 6);  // each ECG strip is 10s long\n        const events = Array(eventCount).fill(leadConstant.lead).map(createEvent);\n        const axisFactor = Math.cos( (leadConstant.phase - 80) * (22 / 7) / 180 )\n        return {  ...leadConstant, events, axisFactor }\n    }\n\n    return constants.leadConstants.map(constantToDetail);\n}\n\nconst addWaves = (waves: WaveParameters, [waveLetter, settings]: WaveParameterEntry): WaveParameters => {\n    for (const [setting, value] of Object.entries(settings)) {\n        waves[waveLetter][setting as SettingName] *= value\n    }\n    return waves;\n}"]},"metadata":{},"sourceType":"module"}