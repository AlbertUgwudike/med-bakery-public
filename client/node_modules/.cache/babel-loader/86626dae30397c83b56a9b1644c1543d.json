{"ast":null,"code":"import _regeneratorRuntime from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport var createWebmPcmMediaRecorderFactory = function createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) {\n  return function (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) {\n    var audioTracks = mediaStream.getAudioTracks();\n    var bufferedArrayBuffers = []; // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n    var channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    var nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    var sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    var promisedPartialRecording = null;\n\n    var stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n    var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    var requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(encoderId, timeslice) {\n        var arrayBuffers;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return encode(encoderId, timeslice);\n\n              case 2:\n                arrayBuffers = _context.sent;\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                  bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray(arrayBuffers));\n                } else {\n                  dispatchDataAvailableEvent(arrayBuffers);\n                  promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                }\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function requestNextPartialRecording(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var stop = function stop() {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(function () {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      stopRecording();\n\n      stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', function () {\n      stop(); // Bug #3 & #4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', function () {\n      return eventTarget.dispatchEvent(new Event('start'));\n    });\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      pause: function pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume: function resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start: function start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n\n          var isRecording = false;\n          var isStopped = false; // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n          var pendingInvocations = 0;\n          var promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n\n          stopRecording = function stopRecording() {\n            isStopped = true;\n          };\n\n          var removeEventListener = on(nativeMediaRecorder, 'dataavailable')(function (_ref2) {\n            var data = _ref2.data;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n                var _ref3$dataView, dataView, _ref3$elementType, elementType, encoderId, port, arrayBuffer, currentDataView, lengthAndValue, value, _decodeWebMChunk, currentElementType, offset, contents, remainingDataView;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _ref3$dataView = _ref3.dataView, dataView = _ref3$dataView === void 0 ? null : _ref3$dataView, _ref3$elementType = _ref3.elementType, elementType = _ref3$elementType === void 0 ? null : _ref3$elementType, encoderId = _ref3.encoderId, port = _ref3.port;\n                        _context2.next = 3;\n                        return data.arrayBuffer();\n\n                      case 3:\n                        arrayBuffer = _context2.sent;\n                        pendingInvocations -= 1;\n                        currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([].concat(_toConsumableArray(dataView.buffers), [arrayBuffer]), dataView.byteOffset);\n\n                        if (!(!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped)) {\n                          _context2.next = 14;\n                          break;\n                        }\n\n                        lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                        if (!(lengthAndValue === null)) {\n                          _context2.next = 10;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: currentDataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 10:\n                        value = lengthAndValue.value;\n\n                        if (!(value !== 172351395)) {\n                          _context2.next = 13;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: dataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 13:\n                        isRecording = true;\n\n                      case 14:\n                        _decodeWebMChunk = decodeWebMChunk(currentDataView, elementType, channelCount), currentElementType = _decodeWebMChunk.currentElementType, offset = _decodeWebMChunk.offset, contents = _decodeWebMChunk.contents;\n                        remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n                        contents.forEach(function (content) {\n                          return port.postMessage(content, content.map(function (_ref5) {\n                            var buffer = _ref5.buffer;\n                            return buffer;\n                          }));\n                        });\n\n                        if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                          encode(encoderId, null).then(function (arrayBuffers) {\n                            dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray(arrayBuffers)));\n                            bufferedArrayBuffers.length = 0;\n                            eventTarget.dispatchEvent(new Event('stop'));\n                          });\n                          port.postMessage([]);\n                          port.close();\n                          removeEventListener();\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: remainingDataView,\n                          elementType: currentElementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 19:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          });\n\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(function (_ref6) {\n              var encoderId = _ref6.encoderId;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n      stop: stop\n    };\n  };\n};","map":null,"metadata":{},"sourceType":"module"}