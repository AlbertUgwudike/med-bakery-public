{"ast":null,"code":"export var createNativeMediaRecorderFactory = function createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError) {\n  return function (nativeMediaRecorderConstructor, stream, mediaRecorderOptions) {\n    var bufferedBlobs = [];\n    var dataAvailableListeners = new WeakMap();\n    var errorListeners = new WeakMap();\n    var nativeMediaRecorder = new nativeMediaRecorderConstructor(stream, mediaRecorderOptions);\n    var stopListeners = new WeakMap();\n    var isActive = true;\n\n    nativeMediaRecorder.addEventListener = function (addEventListener) {\n      return function (type, listener, options) {\n        var patchedEventListener = listener;\n\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = function patchedEventListener(event) {\n              setTimeout(function () {\n                if (isActive && nativeMediaRecorder.state === 'inactive') {\n                  bufferedBlobs.push(event.data);\n                } else {\n                  if (bufferedBlobs.length > 0) {\n                    var blob = event.data;\n                    Object.defineProperty(event, 'data', {\n                      value: new Blob([].concat(bufferedBlobs, [blob]), {\n                        type: blob.type\n                      })\n                    });\n                    bufferedBlobs.length = 0;\n                  }\n\n                  listener.call(nativeMediaRecorder, event);\n                }\n              });\n            };\n\n            dataAvailableListeners.set(listener, patchedEventListener);\n          } else if (type === 'error') {\n            // Bug #12 & #13: Firefox fires a regular event with an error property.\n            patchedEventListener = function patchedEventListener(event) {\n              // Bug #3 & #4: Chrome throws an error event without any error.\n              if (event.error === undefined) {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError()\n                })); // Bug #1 & #2: Firefox throws an error event with an UnknownError.\n              } else if (event.error.name === 'UnknownError') {\n                var message = event.error.message;\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: createInvalidModificationError(message)\n                }));\n              } else if (event instanceof ErrorEvent) {\n                listener.call(nativeMediaRecorder, event);\n              } else {\n                listener.call(nativeMediaRecorder, new ErrorEvent('error', {\n                  error: event.error\n                }));\n              }\n            };\n\n            errorListeners.set(listener, patchedEventListener);\n          } else if (type === 'stop') {\n            // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n            patchedEventListener = function patchedEventListener(event) {\n              isActive = false;\n              setTimeout(function () {\n                return listener.call(nativeMediaRecorder, event);\n              });\n            };\n\n            stopListeners.set(listener, patchedEventListener);\n          }\n        }\n\n        return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    }(nativeMediaRecorder.addEventListener);\n\n    nativeMediaRecorder.dispatchEvent = function (dispatchEvent) {\n      // Bug #7 & #8: Chrome fires the dataavailable and stop events before it fires the error event.\n      return function (event) {\n        var wasActive;\n        setTimeout(function () {\n          wasActive = isActive;\n          isActive = false;\n        });\n        var returnValue = dispatchEvent.call(nativeMediaRecorder, event);\n        setTimeout(function () {\n          return isActive = wasActive;\n        });\n        return returnValue;\n      };\n    }(nativeMediaRecorder.dispatchEvent);\n\n    nativeMediaRecorder.removeEventListener = function (removeEventListener) {\n      return function (type, listener, options) {\n        var patchedEventListener = listener;\n\n        if (typeof listener === 'function') {\n          if (type === 'dataavailable') {\n            var dataAvailableListener = dataAvailableListeners.get(listener);\n\n            if (dataAvailableListener !== undefined) {\n              patchedEventListener = dataAvailableListener;\n            }\n          } else if (type === 'error') {\n            var errorListener = errorListeners.get(listener);\n\n            if (errorListener !== undefined) {\n              patchedEventListener = errorListener;\n            }\n          } else if (type === 'stop') {\n            var stopListener = stopListeners.get(listener);\n\n            if (stopListener !== undefined) {\n              patchedEventListener = stopListener;\n            }\n          }\n        }\n\n        return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);\n      };\n    }(nativeMediaRecorder.removeEventListener);\n\n    nativeMediaRecorder.start = function (start) {\n      return function (timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaRecorderOptions.mimeType !== undefined && mediaRecorderOptions.mimeType.startsWith('audio/') && stream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        isActive = timeslice !== undefined;\n        return timeslice === undefined ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);\n      };\n    }(nativeMediaRecorder.start);\n\n    return nativeMediaRecorder;\n  };\n};","map":null,"metadata":{},"sourceType":"module"}