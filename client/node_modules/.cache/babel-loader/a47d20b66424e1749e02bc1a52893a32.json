{"ast":null,"code":"import _regeneratorRuntime from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _asyncToGenerator from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport var createWebmPcmMediaRecorderFactory = function createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) {\n  return function (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) {\n    var audioTracks = mediaStream.getAudioTracks();\n    var bufferedArrayBuffers = []; // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n    var channelCount = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().channelCount;\n    var nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, {\n      mimeType: 'audio/webm;codecs=pcm'\n    });\n    var sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n    var promisedPartialRecording = null;\n\n    var stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n    var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    var requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(encoderId, timeslice) {\n        var arrayBuffers;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return encode(encoderId, timeslice);\n\n              case 2:\n                arrayBuffers = _context.sent;\n\n                if (nativeMediaRecorder.state === 'inactive') {\n                  bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray(arrayBuffers));\n                } else {\n                  dispatchDataAvailableEvent(arrayBuffers);\n                  promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                }\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function requestNextPartialRecording(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var stop = function stop() {\n      if (nativeMediaRecorder.state === 'inactive') {\n        return;\n      }\n\n      if (promisedPartialRecording !== null) {\n        promisedPartialRecording.catch(function () {\n          /* @todo Only catch the errors caused by a duplicate call to encode. */\n        });\n        promisedPartialRecording = null;\n      }\n\n      stopRecording();\n\n      stopRecording = function stopRecording() {}; // tslint:disable-line:no-empty\n\n\n      nativeMediaRecorder.stop();\n    };\n\n    nativeMediaRecorder.addEventListener('error', function () {\n      stop(); // Bug #3 & #4: Chrome throws an error event without any error.\n\n      eventTarget.dispatchEvent(new ErrorEvent('error', {\n        error: createInvalidModificationError()\n      }));\n    });\n    nativeMediaRecorder.addEventListener('start', function () {\n      return eventTarget.dispatchEvent(new Event('start'));\n    });\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return nativeMediaRecorder.state;\n      },\n\n      pause: function pause() {\n        return nativeMediaRecorder.pause();\n      },\n      resume: function resume() {\n        return nativeMediaRecorder.resume();\n      },\n      start: function start(timeslice) {\n        /*\n         * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n         * codec.\n         */\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        if (nativeMediaRecorder.state === 'inactive') {\n          if (sampleRate === undefined) {\n            throw new Error('The sampleRate is not defined.');\n          }\n\n          var isRecording = false;\n          var isStopped = false; // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n\n          var pendingInvocations = 0;\n          var promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n\n          stopRecording = function stopRecording() {\n            isStopped = true;\n          };\n\n          var removeEventListener = on(nativeMediaRecorder, 'dataavailable')(function (_ref2) {\n            var data = _ref2.data;\n            pendingInvocations += 1;\n            promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n                var _ref3$dataView, dataView, _ref3$elementType, elementType, encoderId, port, arrayBuffer, currentDataView, lengthAndValue, value, _decodeWebMChunk, currentElementType, offset, contents, remainingDataView;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        _ref3$dataView = _ref3.dataView, dataView = _ref3$dataView === void 0 ? null : _ref3$dataView, _ref3$elementType = _ref3.elementType, elementType = _ref3$elementType === void 0 ? null : _ref3$elementType, encoderId = _ref3.encoderId, port = _ref3.port;\n                        _context2.next = 3;\n                        return data.arrayBuffer();\n\n                      case 3:\n                        arrayBuffer = _context2.sent;\n                        pendingInvocations -= 1;\n                        currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([].concat(_toConsumableArray(dataView.buffers), [arrayBuffer]), dataView.byteOffset);\n\n                        if (!(!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped)) {\n                          _context2.next = 14;\n                          break;\n                        }\n\n                        lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n\n                        if (!(lengthAndValue === null)) {\n                          _context2.next = 10;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: currentDataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 10:\n                        value = lengthAndValue.value;\n\n                        if (!(value !== 172351395)) {\n                          _context2.next = 13;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: dataView,\n                          elementType: elementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 13:\n                        isRecording = true;\n\n                      case 14:\n                        _decodeWebMChunk = decodeWebMChunk(currentDataView, elementType, channelCount), currentElementType = _decodeWebMChunk.currentElementType, offset = _decodeWebMChunk.offset, contents = _decodeWebMChunk.contents;\n                        remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;\n                        contents.forEach(function (content) {\n                          return port.postMessage(content, content.map(function (_ref5) {\n                            var buffer = _ref5.buffer;\n                            return buffer;\n                          }));\n                        });\n\n                        if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                          encode(encoderId, null).then(function (arrayBuffers) {\n                            dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray(arrayBuffers)));\n                            bufferedArrayBuffers.length = 0;\n                            eventTarget.dispatchEvent(new Event('stop'));\n                          });\n                          port.postMessage([]);\n                          port.close();\n                          removeEventListener();\n                        }\n\n                        return _context2.abrupt(\"return\", {\n                          dataView: remainingDataView,\n                          elementType: currentElementType,\n                          encoderId: encoderId,\n                          port: port\n                        });\n\n                      case 19:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref4.apply(this, arguments);\n              };\n            }());\n          });\n\n          if (timeslice !== undefined) {\n            promisedDataViewElementTypeEncoderIdAndPort.then(function (_ref6) {\n              var encoderId = _ref6.encoderId;\n              return promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            });\n          }\n        }\n\n        nativeMediaRecorder.start(100);\n      },\n      stop: stop\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/webm-pcm-media-recorder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { MultiBufferDataView } from 'multi-buffer-data-view';\nimport { on } from 'subscribable-things';\nexport const createWebmPcmMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger) => {\n    return (eventTarget, nativeMediaRecorderConstructor, mediaStream, mimeType) => {\n        const audioTracks = mediaStream.getAudioTracks();\n        const bufferedArrayBuffers = [];\n        // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n        const channelCount = audioTracks.length === 0\n            ? undefined\n            : audioTracks[0].getSettings().channelCount;\n        const nativeMediaRecorder = new nativeMediaRecorderConstructor(mediaStream, { mimeType: 'audio/webm;codecs=pcm' });\n        const sampleRate = audioTracks.length === 0 ? undefined : audioTracks[0].getSettings().sampleRate;\n        let promisedPartialRecording = null;\n        let stopRecording = () => { }; // tslint:disable-line:no-empty\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n            if (nativeMediaRecorder.state === 'inactive') {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n        const stop = () => {\n            if (nativeMediaRecorder.state === 'inactive') {\n                return;\n            }\n            if (promisedPartialRecording !== null) {\n                promisedPartialRecording.catch(() => {\n                    /* @todo Only catch the errors caused by a duplicate call to encode. */\n                });\n                promisedPartialRecording = null;\n            }\n            stopRecording();\n            stopRecording = () => { }; // tslint:disable-line:no-empty\n            nativeMediaRecorder.stop();\n        };\n        nativeMediaRecorder.addEventListener('error', () => {\n            stop();\n            // Bug #3 & #4: Chrome throws an error event without any error.\n            eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n        });\n        nativeMediaRecorder.addEventListener('start', () => eventTarget.dispatchEvent(new Event('start')));\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return nativeMediaRecorder.state;\n            },\n            pause() {\n                return nativeMediaRecorder.pause();\n            },\n            resume() {\n                return nativeMediaRecorder.resume();\n            },\n            start(timeslice) {\n                /*\n                 * Bug #6: Chrome will emit a blob without any data when asked to encode a MediaStream with a video track into an audio\n                 * codec.\n                 */\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                if (nativeMediaRecorder.state === 'inactive') {\n                    if (sampleRate === undefined) {\n                        throw new Error('The sampleRate is not defined.');\n                    }\n                    let isRecording = false;\n                    let isStopped = false;\n                    // Bug #9: Chrome sometimes fires more than one dataavailable event while being inactive.\n                    let pendingInvocations = 0;\n                    let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);\n                    stopRecording = () => {\n                        isStopped = true;\n                    };\n                    const removeEventListener = on(nativeMediaRecorder, 'dataavailable')(({ data }) => {\n                        pendingInvocations += 1;\n                        promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async ({ dataView = null, elementType = null, encoderId, port }) => {\n                            const arrayBuffer = await data.arrayBuffer();\n                            pendingInvocations -= 1;\n                            const currentDataView = dataView === null\n                                ? new MultiBufferDataView([arrayBuffer])\n                                : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);\n                            if (!isRecording && nativeMediaRecorder.state === 'recording' && !isStopped) {\n                                const lengthAndValue = readVariableSizeInteger(currentDataView, 0);\n                                if (lengthAndValue === null) {\n                                    return { dataView: currentDataView, elementType, encoderId, port };\n                                }\n                                const { value } = lengthAndValue;\n                                if (value !== 172351395) {\n                                    return { dataView, elementType, encoderId, port };\n                                }\n                                isRecording = true;\n                            }\n                            const { currentElementType, offset, contents } = decodeWebMChunk(currentDataView, elementType, channelCount);\n                            const remainingDataView = offset < currentDataView.byteLength\n                                ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset)\n                                : null;\n                            contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));\n                            if (pendingInvocations === 0 && (nativeMediaRecorder.state === 'inactive' || isStopped)) {\n                                encode(encoderId, null).then((arrayBuffers) => {\n                                    dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                                    bufferedArrayBuffers.length = 0;\n                                    eventTarget.dispatchEvent(new Event('stop'));\n                                });\n                                port.postMessage([]);\n                                port.close();\n                                removeEventListener();\n                            }\n                            return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };\n                        });\n                    });\n                    if (timeslice !== undefined) {\n                        promisedDataViewElementTypeEncoderIdAndPort.then(({ encoderId }) => (promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice)));\n                    }\n                }\n                nativeMediaRecorder.start(100);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=webm-pcm-media-recorder.js.map"]},"metadata":{},"sourceType":"module"}