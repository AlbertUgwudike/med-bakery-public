{"ast":null,"code":"import _classCallCheck from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _assertThisInitialized from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/createSuper\";\nexport var createMediaRecorderConstructor = function createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) {\n  return /*#__PURE__*/function (_eventTargetConstruct) {\n    _inherits(MediaRecorder, _eventTargetConstruct);\n\n    var _super = _createSuper(MediaRecorder);\n\n    function MediaRecorder(stream) {\n      var _this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, MediaRecorder);\n\n      var mimeType = options.mimeType;\n\n      if (nativeMediaRecorderConstructor !== null && ( // Bug #10: Safari does not yet implement the isTypeSupported() method.\n      mimeType === undefined || nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType))) {\n        var internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        _this = _super.call(this, internalMediaRecorder);\n        _this._internalMediaRecorder = internalMediaRecorder;\n      } else if (mimeType !== undefined && encoderRegexes.some(function (regex) {\n        return regex.test(mimeType);\n      })) {\n        _this = _super.call(this); // Bug #10: Safari does not yet implement the isTypeSupported() method.\n\n        if (nativeMediaRecorderConstructor !== null && nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n          _this._internalMediaRecorder = createWebmPcmMediaRecorder(_assertThisInitialized(_this), nativeMediaRecorderConstructor, stream, mimeType);\n        } else {\n          _this._internalMediaRecorder = createWebAudioMediaRecorder(_assertThisInitialized(_this), stream, mimeType);\n        }\n      } else {\n        // This is creating a native MediaRecorder just to provoke it to throw an error.\n        if (nativeMediaRecorderConstructor !== null) {\n          createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n        }\n\n        throw createNotSupportedError();\n      }\n\n      _this._ondataavailable = null;\n      _this._onerror = null;\n      _this._onpause = null;\n      _this._onresume = null;\n      _this._onstart = null;\n      _this._onstop = null;\n      return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(MediaRecorder, [{\n      key: \"mimeType\",\n      get: function get() {\n        return this._internalMediaRecorder.mimeType;\n      }\n    }, {\n      key: \"ondataavailable\",\n      get: function get() {\n        return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n      },\n      set: function set(value) {\n        if (this._ondataavailable !== null) {\n          this.removeEventListener('dataavailable', this._ondataavailable[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('dataavailable', boundListener);\n          this._ondataavailable = [value, boundListener];\n        } else {\n          this._ondataavailable = null;\n        }\n      }\n    }, {\n      key: \"onerror\",\n      get: function get() {\n        return this._onerror === null ? this._onerror : this._onerror[0];\n      },\n      set: function set(value) {\n        if (this._onerror !== null) {\n          this.removeEventListener('error', this._onerror[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('error', boundListener);\n          this._onerror = [value, boundListener];\n        } else {\n          this._onerror = null;\n        }\n      }\n    }, {\n      key: \"onpause\",\n      get: function get() {\n        return this._onpause === null ? this._onpause : this._onpause[0];\n      },\n      set: function set(value) {\n        if (this._onpause !== null) {\n          this.removeEventListener('pause', this._onpause[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('pause', boundListener);\n          this._onpause = [value, boundListener];\n        } else {\n          this._onpause = null;\n        }\n      }\n    }, {\n      key: \"onresume\",\n      get: function get() {\n        return this._onresume === null ? this._onresume : this._onresume[0];\n      },\n      set: function set(value) {\n        if (this._onresume !== null) {\n          this.removeEventListener('resume', this._onresume[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('resume', boundListener);\n          this._onresume = [value, boundListener];\n        } else {\n          this._onresume = null;\n        }\n      }\n    }, {\n      key: \"onstart\",\n      get: function get() {\n        return this._onstart === null ? this._onstart : this._onstart[0];\n      },\n      set: function set(value) {\n        if (this._onstart !== null) {\n          this.removeEventListener('start', this._onstart[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('start', boundListener);\n          this._onstart = [value, boundListener];\n        } else {\n          this._onstart = null;\n        }\n      }\n    }, {\n      key: \"onstop\",\n      get: function get() {\n        return this._onstop === null ? this._onstop : this._onstop[0];\n      },\n      set: function set(value) {\n        if (this._onstop !== null) {\n          this.removeEventListener('stop', this._onstop[1]);\n        }\n\n        if (typeof value === 'function') {\n          var boundListener = value.bind(this);\n          this.addEventListener('stop', boundListener);\n          this._onstop = [value, boundListener];\n        } else {\n          this._onstop = null;\n        }\n      }\n    }, {\n      key: \"state\",\n      get: function get() {\n        return this._internalMediaRecorder.state;\n      }\n    }, {\n      key: \"pause\",\n      value: function pause() {\n        return this._internalMediaRecorder.pause();\n      }\n    }, {\n      key: \"resume\",\n      value: function resume() {\n        return this._internalMediaRecorder.resume();\n      }\n    }, {\n      key: \"start\",\n      value: function start(timeslice) {\n        return this._internalMediaRecorder.start(timeslice);\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        return this._internalMediaRecorder.stop();\n      }\n    }], [{\n      key: \"isTypeSupported\",\n      value: function isTypeSupported(mimeType) {\n        return nativeMediaRecorderConstructor !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.\n        nativeMediaRecorderConstructor.isTypeSupported !== undefined && nativeMediaRecorderConstructor.isTypeSupported(mimeType) || encoderRegexes.some(function (regex) {\n          return regex.test(mimeType);\n        });\n      }\n    }]);\n\n    return MediaRecorder;\n  }(eventTargetConstructor);\n};","map":{"version":3,"sources":["../../../src/factories/media-recorder-constructor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export const createMediaRecorderConstructor = (createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, eventTargetConstructor, nativeMediaRecorderConstructor) => {\n    return class MediaRecorder extends eventTargetConstructor {\n        constructor(stream, options = {}) {\n            const { mimeType } = options;\n            if (nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                (mimeType === undefined ||\n                    (nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                        nativeMediaRecorderConstructor.isTypeSupported(mimeType)))) {\n                const internalMediaRecorder = createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                super(internalMediaRecorder);\n                this._internalMediaRecorder = internalMediaRecorder;\n            }\n            else if (mimeType !== undefined && encoderRegexes.some((regex) => regex.test(mimeType))) {\n                super();\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                if (nativeMediaRecorderConstructor !== null &&\n                    nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                    nativeMediaRecorderConstructor.isTypeSupported('audio/webm;codecs=pcm')) {\n                    this._internalMediaRecorder = createWebmPcmMediaRecorder(this, nativeMediaRecorderConstructor, stream, mimeType);\n                }\n                else {\n                    this._internalMediaRecorder = createWebAudioMediaRecorder(this, stream, mimeType);\n                }\n            }\n            else {\n                // This is creating a native MediaRecorder just to provoke it to throw an error.\n                if (nativeMediaRecorderConstructor !== null) {\n                    createNativeMediaRecorder(nativeMediaRecorderConstructor, stream, options);\n                }\n                throw createNotSupportedError();\n            }\n            this._ondataavailable = null;\n            this._onerror = null;\n            this._onpause = null;\n            this._onresume = null;\n            this._onstart = null;\n            this._onstop = null;\n        }\n        get mimeType() {\n            return this._internalMediaRecorder.mimeType;\n        }\n        get ondataavailable() {\n            return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];\n        }\n        set ondataavailable(value) {\n            if (this._ondataavailable !== null) {\n                this.removeEventListener('dataavailable', this._ondataavailable[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('dataavailable', boundListener);\n                this._ondataavailable = [value, boundListener];\n            }\n            else {\n                this._ondataavailable = null;\n            }\n        }\n        get onerror() {\n            return this._onerror === null ? this._onerror : this._onerror[0];\n        }\n        set onerror(value) {\n            if (this._onerror !== null) {\n                this.removeEventListener('error', this._onerror[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('error', boundListener);\n                this._onerror = [value, boundListener];\n            }\n            else {\n                this._onerror = null;\n            }\n        }\n        get onpause() {\n            return this._onpause === null ? this._onpause : this._onpause[0];\n        }\n        set onpause(value) {\n            if (this._onpause !== null) {\n                this.removeEventListener('pause', this._onpause[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('pause', boundListener);\n                this._onpause = [value, boundListener];\n            }\n            else {\n                this._onpause = null;\n            }\n        }\n        get onresume() {\n            return this._onresume === null ? this._onresume : this._onresume[0];\n        }\n        set onresume(value) {\n            if (this._onresume !== null) {\n                this.removeEventListener('resume', this._onresume[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('resume', boundListener);\n                this._onresume = [value, boundListener];\n            }\n            else {\n                this._onresume = null;\n            }\n        }\n        get onstart() {\n            return this._onstart === null ? this._onstart : this._onstart[0];\n        }\n        set onstart(value) {\n            if (this._onstart !== null) {\n                this.removeEventListener('start', this._onstart[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('start', boundListener);\n                this._onstart = [value, boundListener];\n            }\n            else {\n                this._onstart = null;\n            }\n        }\n        get onstop() {\n            return this._onstop === null ? this._onstop : this._onstop[0];\n        }\n        set onstop(value) {\n            if (this._onstop !== null) {\n                this.removeEventListener('stop', this._onstop[1]);\n            }\n            if (typeof value === 'function') {\n                const boundListener = value.bind(this);\n                this.addEventListener('stop', boundListener);\n                this._onstop = [value, boundListener];\n            }\n            else {\n                this._onstop = null;\n            }\n        }\n        get state() {\n            return this._internalMediaRecorder.state;\n        }\n        pause() {\n            return this._internalMediaRecorder.pause();\n        }\n        resume() {\n            return this._internalMediaRecorder.resume();\n        }\n        start(timeslice) {\n            return this._internalMediaRecorder.start(timeslice);\n        }\n        stop() {\n            return this._internalMediaRecorder.stop();\n        }\n        static isTypeSupported(mimeType) {\n            return ((nativeMediaRecorderConstructor !== null &&\n                // Bug #10: Safari does not yet implement the isTypeSupported() method.\n                nativeMediaRecorderConstructor.isTypeSupported !== undefined &&\n                nativeMediaRecorderConstructor.isTypeSupported(mimeType)) ||\n                encoderRegexes.some((regex) => regex.test(mimeType)));\n        }\n    };\n};\n//# sourceMappingURL=media-recorder-constructor.js.map"]},"metadata":{},"sourceType":"module"}