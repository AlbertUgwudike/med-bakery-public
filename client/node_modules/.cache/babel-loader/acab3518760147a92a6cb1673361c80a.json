{"ast":null,"code":"import _slicedToArray from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/albert/projects/med-bakery-react/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nvar ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.'; // @todo This should live in a separate file.\n\nvar createPromisedAudioNodesEncoderIdAndPort = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(audioBuffer, audioContext, channelCount, mediaStream, mimeType) {\n    var _yield$instantiate, encoderId, port, audioBufferSourceNode, mediaStreamAudioSourceNode, recorderAudioWorkletNode;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return instantiate(mimeType, audioContext.sampleRate);\n\n          case 2:\n            _yield$instantiate = _context.sent;\n            encoderId = _yield$instantiate.encoderId;\n            port = _yield$instantiate.port;\n\n            if (!(AudioWorkletNode === undefined)) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error(ERROR_MESSAGE);\n\n          case 7:\n            audioBufferSourceNode = new AudioBufferSourceNode(audioContext, {\n              buffer: audioBuffer\n            });\n            mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, {\n              mediaStream: mediaStream\n            });\n            recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, {\n              channelCount: channelCount\n            });\n            return _context.abrupt(\"return\", {\n              audioBufferSourceNode: audioBufferSourceNode,\n              encoderId: encoderId,\n              mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n              port: port,\n              recorderAudioWorkletNode: recorderAudioWorkletNode\n            });\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function createPromisedAudioNodesEncoderIdAndPort(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexport var createWebAudioMediaRecorderFactory = function createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) {\n  return function (eventTarget, mediaStream, mimeType) {\n    var _a;\n\n    var sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n    var audioContext = new MinimalAudioContext({\n      latencyHint: 'playback',\n      sampleRate: sampleRate\n    });\n    var length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n    var audioBuffer = new AudioBuffer({\n      length: length,\n      sampleRate: audioContext.sampleRate\n    });\n    var bufferedArrayBuffers = [];\n    var promisedAudioWorkletModule = addRecorderAudioWorkletModule(function (url) {\n      if (addAudioWorkletModule === undefined) {\n        throw new Error(ERROR_MESSAGE);\n      }\n\n      return addAudioWorkletModule(audioContext, url);\n    });\n    var abortRecording = null;\n    var intervalId = null;\n    var promisedAudioNodesAndEncoderId = null;\n    var promisedPartialRecording = null;\n    var isAudioContextRunning = true;\n\n    var dispatchDataAvailableEvent = function dispatchDataAvailableEvent(arrayBuffers) {\n      eventTarget.dispatchEvent(createBlobEvent('dataavailable', {\n        data: new Blob(arrayBuffers, {\n          type: mimeType\n        })\n      }));\n    };\n\n    var requestNextPartialRecording = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(encoderId, timeslice) {\n        var arrayBuffers;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return encode(encoderId, timeslice);\n\n              case 2:\n                arrayBuffers = _context2.sent;\n\n                if (promisedAudioNodesAndEncoderId === null) {\n                  bufferedArrayBuffers.push.apply(bufferedArrayBuffers, _toConsumableArray(arrayBuffers));\n                } else {\n                  dispatchDataAvailableEvent(arrayBuffers);\n                  promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                }\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      return function requestNextPartialRecording(_x6, _x7) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    var _resume = function resume() {\n      isAudioContextRunning = true;\n      return audioContext.resume();\n    };\n\n    var stop = function stop() {\n      if (promisedAudioNodesAndEncoderId === null) {\n        return;\n      }\n\n      if (abortRecording !== null) {\n        mediaStream.removeEventListener('addtrack', abortRecording);\n        mediaStream.removeEventListener('removetrack', abortRecording);\n      }\n\n      if (intervalId !== null) {\n        clearTimeout(intervalId);\n      }\n\n      promisedAudioNodesAndEncoderId.then( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n          var encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode, arrayBuffers;\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  encoderId = _ref3.encoderId, mediaStreamAudioSourceNode = _ref3.mediaStreamAudioSourceNode, recorderAudioWorkletNode = _ref3.recorderAudioWorkletNode;\n\n                  if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(function () {\n                      /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                  }\n\n                  _context3.next = 4;\n                  return recorderAudioWorkletNode.stop();\n\n                case 4:\n                  mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                  _context3.next = 7;\n                  return encode(encoderId, null);\n\n                case 7:\n                  arrayBuffers = _context3.sent;\n\n                  if (!(promisedAudioNodesAndEncoderId === null)) {\n                    _context3.next = 11;\n                    break;\n                  }\n\n                  _context3.next = 11;\n                  return suspend();\n\n                case 11:\n                  dispatchDataAvailableEvent([].concat(bufferedArrayBuffers, _toConsumableArray(arrayBuffers)));\n                  bufferedArrayBuffers.length = 0;\n                  eventTarget.dispatchEvent(new Event('stop'));\n\n                case 14:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n\n        return function (_x8) {\n          return _ref4.apply(this, arguments);\n        };\n      }());\n      promisedAudioNodesAndEncoderId = null;\n    };\n\n    var suspend = function suspend() {\n      isAudioContextRunning = false;\n      return audioContext.suspend();\n    };\n\n    suspend();\n    return {\n      get mimeType() {\n        return mimeType;\n      },\n\n      get state() {\n        return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n      },\n\n      pause: function pause() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (isAudioContextRunning) {\n          suspend();\n          eventTarget.dispatchEvent(new Event('pause'));\n        }\n      },\n      resume: function resume() {\n        if (promisedAudioNodesAndEncoderId === null) {\n          throw createInvalidStateError();\n        }\n\n        if (!isAudioContextRunning) {\n          _resume();\n\n          eventTarget.dispatchEvent(new Event('resume'));\n        }\n      },\n      start: function start(timeslice) {\n        var _a;\n\n        if (promisedAudioNodesAndEncoderId !== null) {\n          throw createInvalidStateError();\n        }\n\n        if (mediaStream.getVideoTracks().length > 0) {\n          throw createNotSupportedError();\n        }\n\n        eventTarget.dispatchEvent(new Event('start'));\n        var audioTracks = mediaStream.getAudioTracks(); // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n\n        var channelCount = audioTracks.length === 0 ? 2 : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n        promisedAudioNodesAndEncoderId = Promise.all([_resume(), promisedAudioWorkletModule.then(function () {\n          return createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType);\n        })]).then( /*#__PURE__*/function () {\n          var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n            var _ref7, _ref7$, audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode;\n\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    _ref7 = _slicedToArray(_ref5, 2), _ref7$ = _ref7[1], audioBufferSourceNode = _ref7$.audioBufferSourceNode, encoderId = _ref7$.encoderId, mediaStreamAudioSourceNode = _ref7$.mediaStreamAudioSourceNode, port = _ref7$.port, recorderAudioWorkletNode = _ref7$.recorderAudioWorkletNode;\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                    _context4.next = 4;\n                    return new Promise(function (resolve) {\n                      audioBufferSourceNode.onended = resolve;\n                      audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                      audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n\n                  case 4:\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n                    _context4.next = 7;\n                    return recorderAudioWorkletNode.record(port);\n\n                  case 7:\n                    if (timeslice !== undefined) {\n                      promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n\n                    return _context4.abrupt(\"return\", {\n                      encoderId: encoderId,\n                      mediaStreamAudioSourceNode: mediaStreamAudioSourceNode,\n                      recorderAudioWorkletNode: recorderAudioWorkletNode\n                    });\n\n                  case 9:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4);\n          }));\n\n          return function (_x9) {\n            return _ref6.apply(this, arguments);\n          };\n        }());\n        var tracks = mediaStream.getTracks();\n\n        abortRecording = function abortRecording() {\n          stop();\n          eventTarget.dispatchEvent(new ErrorEvent('error', {\n            error: createInvalidModificationError()\n          }));\n        };\n\n        mediaStream.addEventListener('addtrack', abortRecording);\n        mediaStream.addEventListener('removetrack', abortRecording);\n        intervalId = setInterval(function () {\n          var currentTracks = mediaStream.getTracks();\n\n          if ((currentTracks.length !== tracks.length || currentTracks.some(function (track, index) {\n            return track !== tracks[index];\n          })) && abortRecording !== null) {\n            abortRecording();\n          }\n        }, 1000);\n      },\n      stop: stop\n    };\n  };\n};","map":{"version":3,"sources":["../../../src/factories/web-audio-media-recorder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { encode, instantiate } from 'media-encoder-host';\nimport { addRecorderAudioWorkletModule, createRecorderAudioWorkletNode } from 'recorder-audio-worklet';\nimport { AudioBuffer, AudioBufferSourceNode, AudioWorkletNode, MediaStreamAudioSourceNode, MinimalAudioContext, addAudioWorkletModule } from 'standardized-audio-context';\nconst ERROR_MESSAGE = 'Missing AudioWorklet support. Maybe this is not running in a secure context.';\n// @todo This should live in a separate file.\nconst createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {\n    const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);\n    if (AudioWorkletNode === undefined) {\n        throw new Error(ERROR_MESSAGE);\n    }\n    const audioBufferSourceNode = new AudioBufferSourceNode(audioContext, { buffer: audioBuffer });\n    const mediaStreamAudioSourceNode = new MediaStreamAudioSourceNode(audioContext, { mediaStream });\n    const recorderAudioWorkletNode = createRecorderAudioWorkletNode(AudioWorkletNode, audioContext, { channelCount });\n    return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };\n};\nexport const createWebAudioMediaRecorderFactory = (createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError) => {\n    return (eventTarget, mediaStream, mimeType) => {\n        var _a;\n        const sampleRate = (_a = mediaStream.getAudioTracks()[0]) === null || _a === void 0 ? void 0 : _a.getSettings().sampleRate;\n        const audioContext = new MinimalAudioContext({ latencyHint: 'playback', sampleRate });\n        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));\n        const audioBuffer = new AudioBuffer({ length, sampleRate: audioContext.sampleRate });\n        const bufferedArrayBuffers = [];\n        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url) => {\n            if (addAudioWorkletModule === undefined) {\n                throw new Error(ERROR_MESSAGE);\n            }\n            return addAudioWorkletModule(audioContext, url);\n        });\n        let abortRecording = null;\n        let intervalId = null;\n        let promisedAudioNodesAndEncoderId = null;\n        let promisedPartialRecording = null;\n        let isAudioContextRunning = true;\n        const dispatchDataAvailableEvent = (arrayBuffers) => {\n            eventTarget.dispatchEvent(createBlobEvent('dataavailable', { data: new Blob(arrayBuffers, { type: mimeType }) }));\n        };\n        const requestNextPartialRecording = async (encoderId, timeslice) => {\n            const arrayBuffers = await encode(encoderId, timeslice);\n            if (promisedAudioNodesAndEncoderId === null) {\n                bufferedArrayBuffers.push(...arrayBuffers);\n            }\n            else {\n                dispatchDataAvailableEvent(arrayBuffers);\n                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n            }\n        };\n        const resume = () => {\n            isAudioContextRunning = true;\n            return audioContext.resume();\n        };\n        const stop = () => {\n            if (promisedAudioNodesAndEncoderId === null) {\n                return;\n            }\n            if (abortRecording !== null) {\n                mediaStream.removeEventListener('addtrack', abortRecording);\n                mediaStream.removeEventListener('removetrack', abortRecording);\n            }\n            if (intervalId !== null) {\n                clearTimeout(intervalId);\n            }\n            promisedAudioNodesAndEncoderId.then(async ({ encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {\n                if (promisedPartialRecording !== null) {\n                    promisedPartialRecording.catch(() => {\n                        /* @todo Only catch the errors caused by a duplicate call to encode. */\n                    });\n                    promisedPartialRecording = null;\n                }\n                await recorderAudioWorkletNode.stop();\n                mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);\n                const arrayBuffers = await encode(encoderId, null);\n                if (promisedAudioNodesAndEncoderId === null) {\n                    await suspend();\n                }\n                dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);\n                bufferedArrayBuffers.length = 0;\n                eventTarget.dispatchEvent(new Event('stop'));\n            });\n            promisedAudioNodesAndEncoderId = null;\n        };\n        const suspend = () => {\n            isAudioContextRunning = false;\n            return audioContext.suspend();\n        };\n        suspend();\n        return {\n            get mimeType() {\n                return mimeType;\n            },\n            get state() {\n                return promisedAudioNodesAndEncoderId === null ? 'inactive' : isAudioContextRunning ? 'recording' : 'paused';\n            },\n            pause() {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n                if (isAudioContextRunning) {\n                    suspend();\n                    eventTarget.dispatchEvent(new Event('pause'));\n                }\n            },\n            resume() {\n                if (promisedAudioNodesAndEncoderId === null) {\n                    throw createInvalidStateError();\n                }\n                if (!isAudioContextRunning) {\n                    resume();\n                    eventTarget.dispatchEvent(new Event('resume'));\n                }\n            },\n            start(timeslice) {\n                var _a;\n                if (promisedAudioNodesAndEncoderId !== null) {\n                    throw createInvalidStateError();\n                }\n                if (mediaStream.getVideoTracks().length > 0) {\n                    throw createNotSupportedError();\n                }\n                eventTarget.dispatchEvent(new Event('start'));\n                const audioTracks = mediaStream.getAudioTracks();\n                // @todo TypeScript v4.4.2 removed the channelCount property from the MediaTrackSettings interface.\n                const channelCount = audioTracks.length === 0\n                    ? 2\n                    : (_a = audioTracks[0].getSettings().channelCount) !== null && _a !== void 0 ? _a : 2;\n                promisedAudioNodesAndEncoderId = Promise.all([\n                    resume(),\n                    promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))\n                ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {\n                    mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);\n                    await new Promise((resolve) => {\n                        audioBufferSourceNode.onended = resolve;\n                        audioBufferSourceNode.connect(recorderAudioWorkletNode);\n                        audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);\n                    });\n                    audioBufferSourceNode.disconnect(recorderAudioWorkletNode);\n                    await recorderAudioWorkletNode.record(port);\n                    if (timeslice !== undefined) {\n                        promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);\n                    }\n                    return { encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };\n                });\n                const tracks = mediaStream.getTracks();\n                abortRecording = () => {\n                    stop();\n                    eventTarget.dispatchEvent(new ErrorEvent('error', { error: createInvalidModificationError() }));\n                };\n                mediaStream.addEventListener('addtrack', abortRecording);\n                mediaStream.addEventListener('removetrack', abortRecording);\n                intervalId = setInterval(() => {\n                    const currentTracks = mediaStream.getTracks();\n                    if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) &&\n                        abortRecording !== null) {\n                        abortRecording();\n                    }\n                }, 1000);\n            },\n            stop\n        };\n    };\n};\n//# sourceMappingURL=web-audio-media-recorder.js.map"]},"metadata":{},"sourceType":"module"}