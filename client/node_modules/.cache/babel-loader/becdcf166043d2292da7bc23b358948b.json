{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useEffect, useState } from \"react\";\nimport WaveSurfer from \"wavesurfer.js\";\nimport { startAudioRecordingId } from \"./types\";\nexport const useLoopTime = upperLimit => {\n  _s();\n\n  const [time, setTime] = useState(upperLimit);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setTime(time => {\n        if (time === 0) {\n          clearInterval(interval);\n          return 0;\n        } else return time - 1;\n      });\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n  return time;\n};\n\n_s(useLoopTime, \"HAa3Zkp51pBKEVcKaVE0XDzjv8k=\");\n\nexport const playStartTone = () => {\n  var _document$getElementB;\n\n  return (_document$getElementB = document.getElementById(startAudioRecordingId)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.play();\n};\nexport const useRecorder = updateFunc => {\n  _s2();\n\n  const [recorder, updateRecorder] = useState(); // attempt to retrieve a user input stream\n\n  const startRecorder = () => {\n    const handleAudioSession = stream => {\n      // cannot make media recorder if stream invalid\n      if (!stream) return () => {};\n      const recorder = new MediaRecorder(stream);\n\n      recorder.ondataavailable = function (e) {\n        const blob = new Blob([e.data], {\n          type: \"audio/ogg; codecs=opus\"\n        });\n        updateFunc(window.URL.createObjectURL(blob));\n      };\n\n      recorder.onstop = () => {\n        stream.getTracks().forEach(track => track.stop());\n        playStartTone();\n      };\n\n      recorder.start();\n      updateRecorder(recorder);\n    };\n\n    navigator.mediaDevices.getUserMedia({\n      audio: true\n    }).then(handleAudioSession).catch(console.log);\n  };\n\n  return [startRecorder, () => recorder === null || recorder === void 0 ? void 0 : recorder.stop()];\n};\n\n_s2(useRecorder, \"AWW46P3126+v/4zylA7z458PW8w=\");\n\nexport const generateWaveSurfer = (containerId, audioUrl, finishCallback) => {\n  const ws = WaveSurfer.create(waveSurferParams(containerId));\n  if (audioUrl) ws.load(audioUrl);\n  ws.on(\"finish\", finishCallback);\n  return ws;\n};\nexport const waveSurferParams = containerId => ({\n  container: \"#\" + containerId,\n  waveColor: 'white',\n  progressColor: '#FAD000',\n  height: 30,\n  cursorWidth: 0,\n  hideScrollbar: true\n});\nexport const toggleMarkPoint = (station, questionIdx, pointId) => ({ ...station,\n  questions: station.questions.map((q, i) => i === questionIdx ? { ...q,\n    markScheme: q.markScheme.map(ms => ({ ...ms,\n      points: ms.points.map(pt => ({ ...pt,\n        selected: pt.pointId === pointId ? !pt.selected : pt.selected\n      }))\n    }))\n  } : q)\n});\nexport const countPoints = markScheme => {\n  return markScheme.reduce((acc, a) => {\n    return [acc[0] + a.points.reduce((total, pt) => total + (pt.selected ? 1 : 0), 0), acc[1] + a.points.length];\n  }, [0, 0]);\n};","map":{"version":3,"sources":["/Users/albert/projects/med-bakery-react/client/src/components/OSCEPage/hooks.tsx"],"names":["useEffect","useState","WaveSurfer","startAudioRecordingId","useLoopTime","upperLimit","time","setTime","interval","setInterval","clearInterval","playStartTone","document","getElementById","play","useRecorder","updateFunc","recorder","updateRecorder","startRecorder","handleAudioSession","stream","MediaRecorder","ondataavailable","e","blob","Blob","data","type","window","URL","createObjectURL","onstop","getTracks","forEach","track","stop","start","navigator","mediaDevices","getUserMedia","audio","then","catch","console","log","generateWaveSurfer","containerId","audioUrl","finishCallback","ws","create","waveSurferParams","load","on","container","waveColor","progressColor","height","cursorWidth","hideScrollbar","toggleMarkPoint","station","questionIdx","pointId","questions","map","q","i","markScheme","ms","points","pt","selected","countPoints","reduce","acc","a","total","length"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\"\nimport WaveSurfer from \"wavesurfer.js\";\nimport { WaveSurferParams } from \"wavesurfer.js/types/params\";\nimport { MarkSchemeSection, startAudioRecordingId, Station_new } from \"./types\";\n\nexport const useLoopTime = (upperLimit: number): number => {\n    const [time, setTime] = useState(upperLimit);\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n\n            setTime(time => {\n\n                if (time === 0) {\n                    clearInterval(interval)\n                    return 0;\n                } \n\n                else return time - 1;\n            })\n\n        }, 1000);\n\n        return () => clearInterval(interval);\n\n    }, [])\n\n    return time;\n}\n\nexport const playStartTone = () => (document.getElementById(startAudioRecordingId) as HTMLAudioElement)?.play();\n\nexport const useRecorder = (updateFunc: ((audio: string) => void)): [() => void, () => void] => {\n    const [recorder, updateRecorder] = useState<MediaRecorder>();\n\n    // attempt to retrieve a user input stream\n    const startRecorder = () => {\n        \n        const handleAudioSession = (stream: MediaStream) => {\n            // cannot make media recorder if stream invalid\n            if (!stream) return () => {};\n\n            const recorder = new MediaRecorder(stream);\n\n            recorder.ondataavailable = function(this, e)  {\n                const blob = new Blob([e.data], { type: \"audio/ogg; codecs=opus\" });\n                updateFunc(window.URL.createObjectURL(blob))\n            };\n\n            recorder.onstop = () => {\n                stream.getTracks().forEach(track => track.stop());\n                playStartTone();\n            }\n\n            recorder.start()\n\n            updateRecorder(recorder);\n        }\n\n        navigator.mediaDevices.getUserMedia({ audio: true })\n            .then(handleAudioSession)\n            .catch(console.log)\n\n    }\n\n    return [startRecorder, () => recorder?.stop()];\n}\n\nexport const generateWaveSurfer = (containerId: string, audioUrl: string, finishCallback: () => void) => {\n    const ws = WaveSurfer.create(waveSurferParams(containerId));\n    if (audioUrl) ws.load(audioUrl);\n    ws.on(\"finish\", finishCallback)\n    return ws;\n}\n\n\nexport const waveSurferParams = (containerId: string) => ({\n    container: \"#\" + containerId,\n    waveColor: 'white',\n    progressColor: '#FAD000',\n    height: 30,\n    cursorWidth: 0,\n    hideScrollbar: true\n})\n\nexport const toggleMarkPoint = (station: Station_new, questionIdx: number, pointId: number): Station_new => (\n    {\n        ...station,\n        questions: station.questions.map((q, i) => i === questionIdx\n            ? { \n                ...q, \n                markScheme: q.markScheme.map(ms => ({\n                    ...ms,\n                    points: ms.points.map(pt => ({ \n                        ...pt, \n                        selected: pt.pointId === pointId ? !pt.selected : pt.selected \n                    }))\n                })) \n            }\n            : q\n        )\n    } \n)\n\nexport const countPoints = (markScheme: MarkSchemeSection[]): [number, number] => {\n    return markScheme.reduce((acc, a) => {\n        return [ \n            acc[0] + a.points.reduce((total, pt) => total + (pt.selected ? 1 : 0), 0), \n            acc[1] + a.points.length \n        ]\n    }, [0, 0])\n}"]},"metadata":{},"sourceType":"module"}