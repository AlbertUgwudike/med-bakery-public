{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReactMediaRecorder = exports.useReactMediaRecorder = exports.RecorderErrors = void 0;\n\nvar extendable_media_recorder_1 = require(\"extendable-media-recorder\");\n\nvar react_1 = require(\"react\");\n\nvar extendable_media_recorder_wav_encoder_1 = require(\"extendable-media-recorder-wav-encoder\");\n\nvar RecorderErrors;\n\n(function (RecorderErrors) {\n  RecorderErrors[\"AbortError\"] = \"media_aborted\";\n  RecorderErrors[\"NotAllowedError\"] = \"permission_denied\";\n  RecorderErrors[\"NotFoundError\"] = \"no_specified_media_found\";\n  RecorderErrors[\"NotReadableError\"] = \"media_in_use\";\n  RecorderErrors[\"OverconstrainedError\"] = \"invalid_media_constraints\";\n  RecorderErrors[\"TypeError\"] = \"no_constraints\";\n  RecorderErrors[\"NONE\"] = \"\";\n  RecorderErrors[\"NO_RECORDER\"] = \"recorder_error\";\n})(RecorderErrors = exports.RecorderErrors || (exports.RecorderErrors = {}));\n\nfunction useReactMediaRecorder(_a) {\n  var _this = this;\n\n  var _b = _a.audio,\n      audio = _b === void 0 ? true : _b,\n      _c = _a.video,\n      video = _c === void 0 ? false : _c,\n      _d = _a.onStop,\n      onStop = _d === void 0 ? function () {\n    return null;\n  } : _d,\n      _e = _a.onStart,\n      onStart = _e === void 0 ? function () {\n    return null;\n  } : _e,\n      blobPropertyBag = _a.blobPropertyBag,\n      _f = _a.screen,\n      screen = _f === void 0 ? false : _f,\n      _g = _a.mediaRecorderOptions,\n      mediaRecorderOptions = _g === void 0 ? undefined : _g,\n      _h = _a.customMediaStream,\n      customMediaStream = _h === void 0 ? null : _h,\n      _j = _a.stopStreamsOnStop,\n      stopStreamsOnStop = _j === void 0 ? true : _j,\n      _k = _a.askPermissionOnMount,\n      askPermissionOnMount = _k === void 0 ? false : _k;\n  var mediaRecorder = (0, react_1.useRef)(null);\n  var mediaChunks = (0, react_1.useRef)([]);\n  var mediaStream = (0, react_1.useRef)(null);\n\n  var _l = (0, react_1.useState)(\"idle\"),\n      status = _l[0],\n      setStatus = _l[1];\n\n  var _m = (0, react_1.useState)(false),\n      isAudioMuted = _m[0],\n      setIsAudioMuted = _m[1];\n\n  var _o = (0, react_1.useState)(undefined),\n      mediaBlobUrl = _o[0],\n      setMediaBlobUrl = _o[1];\n\n  var _p = (0, react_1.useState)(\"NONE\"),\n      error = _p[0],\n      setError = _p[1];\n\n  (0, react_1.useEffect)(function () {\n    var setup = function setup() {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _a = extendable_media_recorder_1.register;\n              return [4, (0, extendable_media_recorder_wav_encoder_1.connect)()];\n\n            case 1:\n              return [4, _a.apply(void 0, [_b.sent()])];\n\n            case 2:\n              _b.sent();\n\n              return [2];\n          }\n        });\n      });\n    };\n\n    setup();\n  }, []);\n  var getMediaStream = (0, react_1.useCallback)(function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var requiredMedia, stream_1, audioStream, stream, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            setStatus(\"acquiring_media\");\n            requiredMedia = {\n              audio: typeof audio === \"boolean\" ? !!audio : audio,\n              video: typeof video === \"boolean\" ? !!video : video\n            };\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 9,, 10]);\n\n            if (!customMediaStream) return [3, 2];\n            mediaStream.current = customMediaStream;\n            return [3, 8];\n\n          case 2:\n            if (!screen) return [3, 6];\n            return [4, window.navigator.mediaDevices.getDisplayMedia({\n              video: video || true\n            })];\n\n          case 3:\n            stream_1 = _a.sent();\n            stream_1.getVideoTracks()[0].addEventListener(\"ended\", function () {\n              stopRecording();\n            });\n            if (!audio) return [3, 5];\n            return [4, window.navigator.mediaDevices.getUserMedia({\n              audio: audio\n            })];\n\n          case 4:\n            audioStream = _a.sent();\n            audioStream.getAudioTracks().forEach(function (audioTrack) {\n              return stream_1.addTrack(audioTrack);\n            });\n            _a.label = 5;\n\n          case 5:\n            mediaStream.current = stream_1;\n            return [3, 8];\n\n          case 6:\n            return [4, window.navigator.mediaDevices.getUserMedia(requiredMedia)];\n\n          case 7:\n            stream = _a.sent();\n            mediaStream.current = stream;\n            _a.label = 8;\n\n          case 8:\n            setStatus(\"idle\");\n            return [3, 10];\n\n          case 9:\n            error_1 = _a.sent();\n            setError(error_1.name);\n            setStatus(\"idle\");\n            return [3, 10];\n\n          case 10:\n            return [2];\n        }\n      });\n    });\n  }, [audio, video, screen]);\n  (0, react_1.useEffect)(function () {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn\\'t support screen capturing\");\n      }\n    }\n\n    var checkConstraints = function checkConstraints(mediaType) {\n      var supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();\n      var unSupportedConstraints = Object.keys(mediaType).filter(function (constraint) {\n        return !supportedMediaConstraints[constraint];\n      });\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(\"The constraints \".concat(unSupportedConstraints.join(\",\"), \" doesn't support on this browser. Please check your ReactMediaRecorder component.\"));\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(\"The specified MIME type you supplied for MediaRecorder doesn't support this browser\");\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return function () {\n      if (mediaStream.current) {\n        var tracks = mediaStream.current.getTracks();\n        tracks.forEach(function (track) {\n          return track.clone().stop();\n        });\n      }\n    };\n  }, [audio, screen, video, getMediaStream, mediaRecorderOptions, askPermissionOnMount]);\n\n  var startRecording = function startRecording() {\n    return __awaiter(_this, void 0, void 0, function () {\n      var isStreamEnded;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            setError(\"NONE\");\n            if (!!mediaStream.current) return [3, 2];\n            return [4, getMediaStream()];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (!mediaStream.current) return [3, 5];\n            isStreamEnded = mediaStream.current.getTracks().some(function (track) {\n              return track.readyState === \"ended\";\n            });\n            if (!isStreamEnded) return [3, 4];\n            return [4, getMediaStream()];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            if (!mediaStream.current.active) {\n              return [2];\n            }\n\n            mediaRecorder.current = new extendable_media_recorder_1.MediaRecorder(mediaStream.current, mediaRecorderOptions || undefined);\n            mediaRecorder.current.ondataavailable = onRecordingActive;\n            mediaRecorder.current.onstop = onRecordingStop;\n            mediaRecorder.current.onstart = onRecordingStart;\n\n            mediaRecorder.current.onerror = function () {\n              setError(\"NO_RECORDER\");\n              setStatus(\"idle\");\n            };\n\n            mediaRecorder.current.start();\n            setStatus(\"recording\");\n            _a.label = 5;\n\n          case 5:\n            return [2];\n        }\n      });\n    });\n  };\n\n  var onRecordingActive = function onRecordingActive(_a) {\n    var data = _a.data;\n    mediaChunks.current.push(data);\n  };\n\n  var onRecordingStart = function onRecordingStart() {\n    onStart();\n  };\n\n  var onRecordingStop = function onRecordingStop() {\n    var chunk = mediaChunks.current[0];\n    var blobProperty = Object.assign({\n      type: chunk.type\n    }, blobPropertyBag || (video ? {\n      type: \"video/mp4\"\n    } : {\n      type: \"audio/wav\"\n    }));\n    var blob = new Blob(mediaChunks.current, blobProperty);\n    var url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  var _muteAudio = function muteAudio(mute) {\n    setIsAudioMuted(mute);\n\n    if (mediaStream.current) {\n      mediaStream.current.getAudioTracks().forEach(function (audioTrack) {\n        return audioTrack.enabled = !mute;\n      });\n    }\n  };\n\n  var pauseRecording = function pauseRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n\n  var resumeRecording = function resumeRecording() {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  var stopRecording = function stopRecording() {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n\n        if (stopStreamsOnStop) {\n          mediaStream.current && mediaStream.current.getTracks().forEach(function (track) {\n            return track.stop();\n          });\n        }\n\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    muteAudio: function muteAudio() {\n      return _muteAudio(true);\n    },\n    unMuteAudio: function unMuteAudio() {\n      return _muteAudio(false);\n    },\n    startRecording: startRecording,\n    pauseRecording: pauseRecording,\n    resumeRecording: resumeRecording,\n    stopRecording: stopRecording,\n    mediaBlobUrl: mediaBlobUrl,\n    status: status,\n    isAudioMuted: isAudioMuted,\n    previewStream: mediaStream.current ? new MediaStream(mediaStream.current.getVideoTracks()) : null,\n    previewAudioStream: mediaStream.current ? new MediaStream(mediaStream.current.getAudioTracks()) : null,\n    clearBlobUrl: function clearBlobUrl() {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n\n      setMediaBlobUrl(undefined);\n      setStatus(\"idle\");\n    }\n  };\n}\n\nexports.useReactMediaRecorder = useReactMediaRecorder;\n\nvar ReactMediaRecorder = function ReactMediaRecorder(props) {\n  return props.render(useReactMediaRecorder(props));\n};\n\nexports.ReactMediaRecorder = ReactMediaRecorder;","map":null,"metadata":{},"sourceType":"script"}