{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n    return function (set) {\n      var number = generateUniqueNumber(set);\n      set.add(number);\n      return number;\n    };\n  };\n\n  var createCache = function createCache(lastNumberWeakMap) {\n    return function (collection, nextNumber) {\n      lastNumberWeakMap.set(collection, nextNumber);\n      return nextNumber;\n    };\n  };\n  /*\n   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n   * is fairly new.\n   */\n\n\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n  var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n  var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n\n  var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n    return function (collection) {\n      var lastNumber = lastNumberWeakMap.get(collection);\n      /*\n       * Let's try the cheapest algorithm first. It might fail to produce a new\n       * number, but it is so cheap that it is okay to take the risk. Just\n       * increase the last number by one or reset it to 0 if we reached the upper\n       * bound of SMIs (which stands for small integers). When the last number is\n       * unknown it is assumed that the collection contains zero based consecutive\n       * numbers.\n       */\n\n      var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n      if (!collection.has(nextNumber)) {\n        return cache(collection, nextNumber);\n      }\n      /*\n       * If there are less than half of 2 ** 30 numbers stored in the collection,\n       * the chance to generate a new random number in the range from 0 to 2 ** 30\n       * is at least 50%. It's benifitial to use only SMIs because they perform\n       * much better in any environment based on V8.\n       */\n\n\n      if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n        }\n\n        return cache(collection, nextNumber);\n      } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n      if (collection.size > MAX_SAFE_INTEGER) {\n        throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n      } // Otherwise use the full scale of safely usable integers.\n\n\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n      }\n\n      return cache(collection, nextNumber);\n    };\n  };\n\n  var LAST_NUMBER_WEAK_MAP = new WeakMap();\n  var cache = createCache(LAST_NUMBER_WEAK_MAP);\n  var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n  var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n  exports.addUniqueNumber = addUniqueNumber;\n  exports.generateUniqueNumber = generateUniqueNumber;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}