{"ast":null,"code":"/*!\n  * Bootstrap v5.1.0 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).bootstrap = e();\n}(this, function () {\n  \"use strict\";\n\n  const t = t => {\n    let e = t.getAttribute(\"data-bs-target\");\n\n    if (!e || \"#\" === e) {\n      let i = t.getAttribute(\"href\");\n      if (!i || !i.includes(\"#\") && !i.startsWith(\".\")) return null;\n      i.includes(\"#\") && !i.startsWith(\"#\") && (i = \"#\" + i.split(\"#\")[1]), e = i && \"#\" !== i ? i.trim() : null;\n    }\n\n    return e;\n  },\n        e = e => {\n    const i = t(e);\n    return i && document.querySelector(i) ? i : null;\n  },\n        i = e => {\n    const i = t(e);\n    return i ? document.querySelector(i) : null;\n  },\n        n = t => {\n    t.dispatchEvent(new Event(\"transitionend\"));\n  },\n        s = t => !(!t || \"object\" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),\n        o = t => s(t) ? t.jquery ? t[0] : t : \"string\" == typeof t && t.length > 0 ? document.querySelector(t) : null,\n        r = (t, e, i) => {\n    Object.keys(i).forEach(n => {\n      const o = i[n],\n            r = e[n],\n            a = r && s(r) ? \"element\" : null == (l = r) ? \"\" + l : {}.toString.call(l).match(/\\s([a-z]+)/i)[1].toLowerCase();\n      var l;\n      if (!new RegExp(o).test(a)) throw new TypeError(`${t.toUpperCase()}: Option \"${n}\" provided type \"${a}\" but expected type \"${o}\".`);\n    });\n  },\n        a = t => !(!s(t) || 0 === t.getClientRects().length) && \"visible\" === getComputedStyle(t).getPropertyValue(\"visibility\"),\n        l = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains(\"disabled\") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute(\"disabled\") && \"false\" !== t.getAttribute(\"disabled\")),\n        c = t => {\n    if (!document.documentElement.attachShadow) return null;\n\n    if (\"function\" == typeof t.getRootNode) {\n      const e = t.getRootNode();\n      return e instanceof ShadowRoot ? e : null;\n    }\n\n    return t instanceof ShadowRoot ? t : t.parentNode ? c(t.parentNode) : null;\n  },\n        h = () => {},\n        d = t => {\n    t.offsetHeight;\n  },\n        u = () => {\n    const {\n      jQuery: t\n    } = window;\n    return t && !document.body.hasAttribute(\"data-bs-no-jquery\") ? t : null;\n  },\n        f = [],\n        p = () => \"rtl\" === document.documentElement.dir,\n        m = t => {\n    var e;\n    e = () => {\n      const e = u();\n\n      if (e) {\n        const i = t.NAME,\n              n = e.fn[i];\n        e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface);\n      }\n    }, \"loading\" === document.readyState ? (f.length || document.addEventListener(\"DOMContentLoaded\", () => {\n      f.forEach(t => t());\n    }), f.push(e)) : e();\n  },\n        g = t => {\n    \"function\" == typeof t && t();\n  },\n        _ = (t, e, i = !0) => {\n    if (!i) return void g(t);\n\n    const s = (t => {\n      if (!t) return 0;\n      let {\n        transitionDuration: e,\n        transitionDelay: i\n      } = window.getComputedStyle(t);\n      const n = Number.parseFloat(e),\n            s = Number.parseFloat(i);\n      return n || s ? (e = e.split(\",\")[0], i = i.split(\",\")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0;\n    })(e) + 5;\n\n    let o = !1;\n\n    const r = ({\n      target: i\n    }) => {\n      i === e && (o = !0, e.removeEventListener(\"transitionend\", r), g(t));\n    };\n\n    e.addEventListener(\"transitionend\", r), setTimeout(() => {\n      o || n(e);\n    }, s);\n  },\n        b = (t, e, i, n) => {\n    let s = t.indexOf(e);\n    if (-1 === s) return t[!i && n ? t.length - 1 : 0];\n    const o = t.length;\n    return s += i ? 1 : -1, n && (s = (s + o) % o), t[Math.max(0, Math.min(s, o - 1))];\n  },\n        v = /[^.]*(?=\\..*)\\.|.*/,\n        y = /\\..*/,\n        w = /::\\d+$/,\n        E = {};\n\n  let A = 1;\n  const T = {\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n  },\n        O = /^(mouseenter|mouseleave)/i,\n        C = new Set([\"click\", \"dblclick\", \"mouseup\", \"mousedown\", \"contextmenu\", \"mousewheel\", \"DOMMouseScroll\", \"mouseover\", \"mouseout\", \"mousemove\", \"selectstart\", \"selectend\", \"keydown\", \"keypress\", \"keyup\", \"orientationchange\", \"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\", \"pointerdown\", \"pointermove\", \"pointerup\", \"pointerleave\", \"pointercancel\", \"gesturestart\", \"gesturechange\", \"gestureend\", \"focus\", \"blur\", \"change\", \"reset\", \"select\", \"submit\", \"focusin\", \"focusout\", \"load\", \"unload\", \"beforeunload\", \"resize\", \"move\", \"DOMContentLoaded\", \"readystatechange\", \"error\", \"abort\", \"scroll\"]);\n\n  function k(t, e) {\n    return e && `${e}::${A++}` || t.uidEvent || A++;\n  }\n\n  function L(t) {\n    const e = k(t);\n    return t.uidEvent = e, E[e] = E[e] || {}, E[e];\n  }\n\n  function x(t, e, i = null) {\n    const n = Object.keys(t);\n\n    for (let s = 0, o = n.length; s < o; s++) {\n      const o = t[n[s]];\n      if (o.originalHandler === e && o.delegationSelector === i) return o;\n    }\n\n    return null;\n  }\n\n  function D(t, e, i) {\n    const n = \"string\" == typeof e,\n          s = n ? i : e;\n    let o = I(t);\n    return C.has(o) || (o = t), [n, s, o];\n  }\n\n  function S(t, e, i, n, s) {\n    if (\"string\" != typeof e || !t) return;\n\n    if (i || (i = n, n = null), O.test(e)) {\n      const t = t => function (e) {\n        if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e);\n      };\n\n      n ? n = t(n) : i = t(i);\n    }\n\n    const [o, r, a] = D(e, i, n),\n          l = L(t),\n          c = l[a] || (l[a] = {}),\n          h = x(c, r, o ? i : null);\n    if (h) return void (h.oneOff = h.oneOff && s);\n    const d = k(r, e.replace(v, \"\")),\n          u = o ? function (t, e, i) {\n      return function n(s) {\n        const o = t.querySelectorAll(e);\n\n        for (let {\n          target: r\n        } = s; r && r !== this; r = r.parentNode) for (let a = o.length; a--;) if (o[a] === r) return s.delegateTarget = r, n.oneOff && P.off(t, s.type, e, i), i.apply(r, [s]);\n\n        return null;\n      };\n    }(t, i, n) : function (t, e) {\n      return function i(n) {\n        return n.delegateTarget = t, i.oneOff && P.off(t, n.type, e), e.apply(t, [n]);\n      };\n    }(t, i);\n    u.delegationSelector = o ? i : null, u.originalHandler = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o);\n  }\n\n  function N(t, e, i, n, s) {\n    const o = x(e[i], n, s);\n    o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent]);\n  }\n\n  function I(t) {\n    return t = t.replace(y, \"\"), T[t] || t;\n  }\n\n  const P = {\n    on(t, e, i, n) {\n      S(t, e, i, n, !1);\n    },\n\n    one(t, e, i, n) {\n      S(t, e, i, n, !0);\n    },\n\n    off(t, e, i, n) {\n      if (\"string\" != typeof e || !t) return;\n      const [s, o, r] = D(e, i, n),\n            a = r !== e,\n            l = L(t),\n            c = e.startsWith(\".\");\n\n      if (void 0 !== o) {\n        if (!l || !l[r]) return;\n        return void N(t, l, r, o, s ? i : null);\n      }\n\n      c && Object.keys(l).forEach(i => {\n        !function (t, e, i, n) {\n          const s = e[i] || {};\n          Object.keys(s).forEach(o => {\n            if (o.includes(n)) {\n              const n = s[o];\n              N(t, e, i, n.originalHandler, n.delegationSelector);\n            }\n          });\n        }(t, l, i, e.slice(1));\n      });\n      const h = l[r] || {};\n      Object.keys(h).forEach(i => {\n        const n = i.replace(w, \"\");\n\n        if (!a || e.includes(n)) {\n          const e = h[i];\n          N(t, l, r, e.originalHandler, e.delegationSelector);\n        }\n      });\n    },\n\n    trigger(t, e, i) {\n      if (\"string\" != typeof e || !t) return null;\n      const n = u(),\n            s = I(e),\n            o = e !== s,\n            r = C.has(s);\n      let a,\n          l = !0,\n          c = !0,\n          h = !1,\n          d = null;\n      return o && n && (a = n.Event(e, i), n(t).trigger(a), l = !a.isPropagationStopped(), c = !a.isImmediatePropagationStopped(), h = a.isDefaultPrevented()), r ? (d = document.createEvent(\"HTMLEvents\"), d.initEvent(s, l, !0)) : d = new CustomEvent(e, {\n        bubbles: l,\n        cancelable: !0\n      }), void 0 !== i && Object.keys(i).forEach(t => {\n        Object.defineProperty(d, t, {\n          get: () => i[t]\n        });\n      }), h && d.preventDefault(), c && t.dispatchEvent(d), d.defaultPrevented && void 0 !== a && a.preventDefault(), d;\n    }\n\n  },\n        j = new Map();\n  var M = {\n    set(t, e, i) {\n      j.has(t) || j.set(t, new Map());\n      const n = j.get(t);\n      n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`);\n    },\n\n    get: (t, e) => j.has(t) && j.get(t).get(e) || null,\n\n    remove(t, e) {\n      if (!j.has(t)) return;\n      const i = j.get(t);\n      i.delete(e), 0 === i.size && j.delete(t);\n    }\n\n  };\n\n  class H {\n    constructor(t) {\n      (t = o(t)) && (this._element = t, M.set(this._element, this.constructor.DATA_KEY, this));\n    }\n\n    dispose() {\n      M.remove(this._element, this.constructor.DATA_KEY), P.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach(t => {\n        this[t] = null;\n      });\n    }\n\n    _queueCallback(t, e, i = !0) {\n      _(t, e, i);\n    }\n\n    static getInstance(t) {\n      return M.get(o(t), this.DATA_KEY);\n    }\n\n    static getOrCreateInstance(t, e = {}) {\n      return this.getInstance(t) || new this(t, \"object\" == typeof e ? e : null);\n    }\n\n    static get VERSION() {\n      return \"5.1.0\";\n    }\n\n    static get NAME() {\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n\n    static get DATA_KEY() {\n      return \"bs.\" + this.NAME;\n    }\n\n    static get EVENT_KEY() {\n      return \".\" + this.DATA_KEY;\n    }\n\n  }\n\n  const B = (t, e = \"hide\") => {\n    const n = \"click.dismiss\" + t.EVENT_KEY,\n          s = t.NAME;\n    P.on(document, n, `[data-bs-dismiss=\"${s}\"]`, function (n) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && n.preventDefault(), l(this)) return;\n      const o = i(this) || this.closest(\".\" + s);\n      t.getOrCreateInstance(o)[e]();\n    });\n  };\n\n  class R extends H {\n    static get NAME() {\n      return \"alert\";\n    }\n\n    close() {\n      if (P.trigger(this._element, \"close.bs.alert\").defaultPrevented) return;\n\n      this._element.classList.remove(\"show\");\n\n      const t = this._element.classList.contains(\"fade\");\n\n      this._queueCallback(() => this._destroyElement(), this._element, t);\n    }\n\n    _destroyElement() {\n      this._element.remove(), P.trigger(this._element, \"closed.bs.alert\"), this.dispose();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = R.getOrCreateInstance(this);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t] || t.startsWith(\"_\") || \"constructor\" === t) throw new TypeError(`No method named \"${t}\"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  B(R, \"close\"), m(R);\n\n  class W extends H {\n    static get NAME() {\n      return \"button\";\n    }\n\n    toggle() {\n      this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(\"active\"));\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = W.getOrCreateInstance(this);\n        \"toggle\" === t && e[t]();\n      });\n    }\n\n  }\n\n  function z(t) {\n    return \"true\" === t || \"false\" !== t && (t === Number(t).toString() ? Number(t) : \"\" === t || \"null\" === t ? null : t);\n  }\n\n  function q(t) {\n    return t.replace(/[A-Z]/g, t => \"-\" + t.toLowerCase());\n  }\n\n  P.on(document, \"click.bs.button.data-api\", '[data-bs-toggle=\"button\"]', t => {\n    t.preventDefault();\n    const e = t.target.closest('[data-bs-toggle=\"button\"]');\n    W.getOrCreateInstance(e).toggle();\n  }), m(W);\n  const F = {\n    setDataAttribute(t, e, i) {\n      t.setAttribute(\"data-bs-\" + q(e), i);\n    },\n\n    removeDataAttribute(t, e) {\n      t.removeAttribute(\"data-bs-\" + q(e));\n    },\n\n    getDataAttributes(t) {\n      if (!t) return {};\n      const e = {};\n      return Object.keys(t.dataset).filter(t => t.startsWith(\"bs\")).forEach(i => {\n        let n = i.replace(/^bs/, \"\");\n        n = n.charAt(0).toLowerCase() + n.slice(1, n.length), e[n] = z(t.dataset[i]);\n      }), e;\n    },\n\n    getDataAttribute: (t, e) => z(t.getAttribute(\"data-bs-\" + q(e))),\n\n    offset(t) {\n      const e = t.getBoundingClientRect();\n      return {\n        top: e.top + window.pageYOffset,\n        left: e.left + window.pageXOffset\n      };\n    },\n\n    position: t => ({\n      top: t.offsetTop,\n      left: t.offsetLeft\n    })\n  },\n        U = {\n    find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),\n    findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),\n    children: (t, e) => [].concat(...t.children).filter(t => t.matches(e)),\n\n    parents(t, e) {\n      const i = [];\n      let n = t.parentNode;\n\n      for (; n && n.nodeType === Node.ELEMENT_NODE && 3 !== n.nodeType;) n.matches(e) && i.push(n), n = n.parentNode;\n\n      return i;\n    },\n\n    prev(t, e) {\n      let i = t.previousElementSibling;\n\n      for (; i;) {\n        if (i.matches(e)) return [i];\n        i = i.previousElementSibling;\n      }\n\n      return [];\n    },\n\n    next(t, e) {\n      let i = t.nextElementSibling;\n\n      for (; i;) {\n        if (i.matches(e)) return [i];\n        i = i.nextElementSibling;\n      }\n\n      return [];\n    },\n\n    focusableChildren(t) {\n      const e = [\"a\", \"button\", \"input\", \"textarea\", \"select\", \"details\", \"[tabindex]\", '[contenteditable=\"true\"]'].map(t => t + ':not([tabindex^=\"-\"])').join(\", \");\n      return this.find(e, t).filter(t => !l(t) && a(t));\n    }\n\n  },\n        $ = {\n    interval: 5e3,\n    keyboard: !0,\n    slide: !1,\n    pause: \"hover\",\n    wrap: !0,\n    touch: !0\n  },\n        V = {\n    interval: \"(number|boolean)\",\n    keyboard: \"boolean\",\n    slide: \"(boolean|string)\",\n    pause: \"(string|boolean)\",\n    wrap: \"boolean\",\n    touch: \"boolean\"\n  },\n        K = \"next\",\n        X = \"prev\",\n        Y = \"left\",\n        Q = \"right\",\n        G = {\n    ArrowLeft: Q,\n    ArrowRight: Y\n  };\n\n  class Z extends H {\n    constructor(t, e) {\n      super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._indicatorsElement = U.findOne(\".carousel-indicators\", this._element), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent), this._addEventListeners();\n    }\n\n    static get Default() {\n      return $;\n    }\n\n    static get NAME() {\n      return \"carousel\";\n    }\n\n    next() {\n      this._slide(K);\n    }\n\n    nextWhenVisible() {\n      !document.hidden && a(this._element) && this.next();\n    }\n\n    prev() {\n      this._slide(X);\n    }\n\n    pause(t) {\n      t || (this._isPaused = !0), U.findOne(\".carousel-item-next, .carousel-item-prev\", this._element) && (n(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n    }\n\n    cycle(t) {\n      t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval));\n    }\n\n    to(t) {\n      this._activeElement = U.findOne(\".active.carousel-item\", this._element);\n\n      const e = this._getItemIndex(this._activeElement);\n\n      if (t > this._items.length - 1 || t < 0) return;\n      if (this._isSliding) return void P.one(this._element, \"slid.bs.carousel\", () => this.to(t));\n      if (e === t) return this.pause(), void this.cycle();\n      const i = t > e ? K : X;\n\n      this._slide(i, this._items[t]);\n    }\n\n    _getConfig(t) {\n      return t = { ...$,\n        ...F.getDataAttributes(this._element),\n        ...(\"object\" == typeof t ? t : {})\n      }, r(\"carousel\", t, V), t;\n    }\n\n    _handleSwipe() {\n      const t = Math.abs(this.touchDeltaX);\n      if (t <= 40) return;\n      const e = t / this.touchDeltaX;\n      this.touchDeltaX = 0, e && this._slide(e > 0 ? Q : Y);\n    }\n\n    _addEventListeners() {\n      this._config.keyboard && P.on(this._element, \"keydown.bs.carousel\", t => this._keydown(t)), \"hover\" === this._config.pause && (P.on(this._element, \"mouseenter.bs.carousel\", t => this.pause(t)), P.on(this._element, \"mouseleave.bs.carousel\", t => this.cycle(t))), this._config.touch && this._touchSupported && this._addTouchEventListeners();\n    }\n\n    _addTouchEventListeners() {\n      const t = t => {\n        !this._pointerEvent || \"pen\" !== t.pointerType && \"touch\" !== t.pointerType ? this._pointerEvent || (this.touchStartX = t.touches[0].clientX) : this.touchStartX = t.clientX;\n      },\n            e = t => {\n        this.touchDeltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this.touchStartX;\n      },\n            i = t => {\n        !this._pointerEvent || \"pen\" !== t.pointerType && \"touch\" !== t.pointerType || (this.touchDeltaX = t.clientX - this.touchStartX), this._handleSwipe(), \"hover\" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(t => this.cycle(t), 500 + this._config.interval));\n      };\n\n      U.find(\".carousel-item img\", this._element).forEach(t => {\n        P.on(t, \"dragstart.bs.carousel\", t => t.preventDefault());\n      }), this._pointerEvent ? (P.on(this._element, \"pointerdown.bs.carousel\", e => t(e)), P.on(this._element, \"pointerup.bs.carousel\", t => i(t)), this._element.classList.add(\"pointer-event\")) : (P.on(this._element, \"touchstart.bs.carousel\", e => t(e)), P.on(this._element, \"touchmove.bs.carousel\", t => e(t)), P.on(this._element, \"touchend.bs.carousel\", t => i(t)));\n    }\n\n    _keydown(t) {\n      if (/input|textarea/i.test(t.target.tagName)) return;\n      const e = G[t.key];\n      e && (t.preventDefault(), this._slide(e));\n    }\n\n    _getItemIndex(t) {\n      return this._items = t && t.parentNode ? U.find(\".carousel-item\", t.parentNode) : [], this._items.indexOf(t);\n    }\n\n    _getItemByOrder(t, e) {\n      const i = t === K;\n      return b(this._items, e, i, this._config.wrap);\n    }\n\n    _triggerSlideEvent(t, e) {\n      const i = this._getItemIndex(t),\n            n = this._getItemIndex(U.findOne(\".active.carousel-item\", this._element));\n\n      return P.trigger(this._element, \"slide.bs.carousel\", {\n        relatedTarget: t,\n        direction: e,\n        from: n,\n        to: i\n      });\n    }\n\n    _setActiveIndicatorElement(t) {\n      if (this._indicatorsElement) {\n        const e = U.findOne(\".active\", this._indicatorsElement);\n        e.classList.remove(\"active\"), e.removeAttribute(\"aria-current\");\n        const i = U.find(\"[data-bs-target]\", this._indicatorsElement);\n\n        for (let e = 0; e < i.length; e++) if (Number.parseInt(i[e].getAttribute(\"data-bs-slide-to\"), 10) === this._getItemIndex(t)) {\n          i[e].classList.add(\"active\"), i[e].setAttribute(\"aria-current\", \"true\");\n          break;\n        }\n      }\n    }\n\n    _updateInterval() {\n      const t = this._activeElement || U.findOne(\".active.carousel-item\", this._element);\n      if (!t) return;\n      const e = Number.parseInt(t.getAttribute(\"data-bs-interval\"), 10);\n      e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n    }\n\n    _slide(t, e) {\n      const i = this._directionToOrder(t),\n            n = U.findOne(\".active.carousel-item\", this._element),\n            s = this._getItemIndex(n),\n            o = e || this._getItemByOrder(i, n),\n            r = this._getItemIndex(o),\n            a = Boolean(this._interval),\n            l = i === K,\n            c = l ? \"carousel-item-start\" : \"carousel-item-end\",\n            h = l ? \"carousel-item-next\" : \"carousel-item-prev\",\n            u = this._orderToDirection(i);\n\n      if (o && o.classList.contains(\"active\")) return void (this._isSliding = !1);\n      if (this._isSliding) return;\n      if (this._triggerSlideEvent(o, u).defaultPrevented) return;\n      if (!n || !o) return;\n      this._isSliding = !0, a && this.pause(), this._setActiveIndicatorElement(o), this._activeElement = o;\n\n      const f = () => {\n        P.trigger(this._element, \"slid.bs.carousel\", {\n          relatedTarget: o,\n          direction: u,\n          from: s,\n          to: r\n        });\n      };\n\n      if (this._element.classList.contains(\"slide\")) {\n        o.classList.add(h), d(o), n.classList.add(c), o.classList.add(c);\n\n        const t = () => {\n          o.classList.remove(c, h), o.classList.add(\"active\"), n.classList.remove(\"active\", h, c), this._isSliding = !1, setTimeout(f, 0);\n        };\n\n        this._queueCallback(t, n, !0);\n      } else n.classList.remove(\"active\"), o.classList.add(\"active\"), this._isSliding = !1, f();\n\n      a && this.cycle();\n    }\n\n    _directionToOrder(t) {\n      return [Q, Y].includes(t) ? p() ? t === Y ? X : K : t === Y ? K : X : t;\n    }\n\n    _orderToDirection(t) {\n      return [K, X].includes(t) ? p() ? t === X ? Y : Q : t === X ? Q : Y : t;\n    }\n\n    static carouselInterface(t, e) {\n      const i = Z.getOrCreateInstance(t, e);\n      let {\n        _config: n\n      } = i;\n      \"object\" == typeof e && (n = { ...n,\n        ...e\n      });\n      const s = \"string\" == typeof e ? e : n.slide;\n      if (\"number\" == typeof e) i.to(e);else if (\"string\" == typeof s) {\n        if (void 0 === i[s]) throw new TypeError(`No method named \"${s}\"`);\n        i[s]();\n      } else n.interval && n.ride && (i.pause(), i.cycle());\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        Z.carouselInterface(this, t);\n      });\n    }\n\n    static dataApiClickHandler(t) {\n      const e = i(this);\n      if (!e || !e.classList.contains(\"carousel\")) return;\n      const n = { ...F.getDataAttributes(e),\n        ...F.getDataAttributes(this)\n      },\n            s = this.getAttribute(\"data-bs-slide-to\");\n      s && (n.interval = !1), Z.carouselInterface(e, n), s && Z.getInstance(e).to(s), t.preventDefault();\n    }\n\n  }\n\n  P.on(document, \"click.bs.carousel.data-api\", \"[data-bs-slide], [data-bs-slide-to]\", Z.dataApiClickHandler), P.on(window, \"load.bs.carousel.data-api\", () => {\n    const t = U.find('[data-bs-ride=\"carousel\"]');\n\n    for (let e = 0, i = t.length; e < i; e++) Z.carouselInterface(t[e], Z.getInstance(t[e]));\n  }), m(Z);\n  const J = {\n    toggle: !0,\n    parent: null\n  },\n        tt = {\n    toggle: \"boolean\",\n    parent: \"(null|element)\"\n  };\n\n  class et extends H {\n    constructor(t, i) {\n      super(t), this._isTransitioning = !1, this._config = this._getConfig(i), this._triggerArray = [];\n      const n = U.find('[data-bs-toggle=\"collapse\"]');\n\n      for (let t = 0, i = n.length; t < i; t++) {\n        const i = n[t],\n              s = e(i),\n              o = U.find(s).filter(t => t === this._element);\n        null !== s && o.length && (this._selector = s, this._triggerArray.push(i));\n      }\n\n      this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n    }\n\n    static get Default() {\n      return J;\n    }\n\n    static get NAME() {\n      return \"collapse\";\n    }\n\n    toggle() {\n      this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (this._isTransitioning || this._isShown()) return;\n      let t,\n          e = [];\n\n      if (this._config.parent) {\n        const t = U.find(\".collapse .collapse\", this._config.parent);\n        e = U.find(\".show, .collapsing\", this._config.parent).filter(e => !t.includes(e));\n      }\n\n      const i = U.findOne(this._selector);\n\n      if (e.length) {\n        const n = e.find(t => i !== t);\n        if (t = n ? et.getInstance(n) : null, t && t._isTransitioning) return;\n      }\n\n      if (P.trigger(this._element, \"show.bs.collapse\").defaultPrevented) return;\n      e.forEach(e => {\n        i !== e && et.getOrCreateInstance(e, {\n          toggle: !1\n        }).hide(), t || M.set(e, \"bs.collapse\", null);\n      });\n\n      const n = this._getDimension();\n\n      this._element.classList.remove(\"collapse\"), this._element.classList.add(\"collapsing\"), this._element.style[n] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n      const s = \"scroll\" + (n[0].toUpperCase() + n.slice(1));\n      this._queueCallback(() => {\n        this._isTransitioning = !1, this._element.classList.remove(\"collapsing\"), this._element.classList.add(\"collapse\", \"show\"), this._element.style[n] = \"\", P.trigger(this._element, \"shown.bs.collapse\");\n      }, this._element, !0), this._element.style[n] = this._element[s] + \"px\";\n    }\n\n    hide() {\n      if (this._isTransitioning || !this._isShown()) return;\n      if (P.trigger(this._element, \"hide.bs.collapse\").defaultPrevented) return;\n\n      const t = this._getDimension();\n\n      this._element.style[t] = this._element.getBoundingClientRect()[t] + \"px\", d(this._element), this._element.classList.add(\"collapsing\"), this._element.classList.remove(\"collapse\", \"show\");\n      const e = this._triggerArray.length;\n\n      for (let t = 0; t < e; t++) {\n        const e = this._triggerArray[t],\n              n = i(e);\n        n && !this._isShown(n) && this._addAriaAndCollapsedClass([e], !1);\n      }\n\n      this._isTransitioning = !0, this._element.style[t] = \"\", this._queueCallback(() => {\n        this._isTransitioning = !1, this._element.classList.remove(\"collapsing\"), this._element.classList.add(\"collapse\"), P.trigger(this._element, \"hidden.bs.collapse\");\n      }, this._element, !0);\n    }\n\n    _isShown(t = this._element) {\n      return t.classList.contains(\"show\");\n    }\n\n    _getConfig(t) {\n      return (t = { ...J,\n        ...F.getDataAttributes(this._element),\n        ...t\n      }).toggle = Boolean(t.toggle), t.parent = o(t.parent), r(\"collapse\", t, tt), t;\n    }\n\n    _getDimension() {\n      return this._element.classList.contains(\"collapse-horizontal\") ? \"width\" : \"height\";\n    }\n\n    _initializeChildren() {\n      if (!this._config.parent) return;\n      const t = U.find(\".collapse .collapse\", this._config.parent);\n      U.find('[data-bs-toggle=\"collapse\"]', this._config.parent).filter(e => !t.includes(e)).forEach(t => {\n        const e = i(t);\n        e && this._addAriaAndCollapsedClass([t], this._isShown(e));\n      });\n    }\n\n    _addAriaAndCollapsedClass(t, e) {\n      t.length && t.forEach(t => {\n        e ? t.classList.remove(\"collapsed\") : t.classList.add(\"collapsed\"), t.setAttribute(\"aria-expanded\", e);\n      });\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = {};\n        \"string\" == typeof t && /show|hide/.test(t) && (e.toggle = !1);\n        const i = et.getOrCreateInstance(this, e);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === i[t]) throw new TypeError(`No method named \"${t}\"`);\n          i[t]();\n        }\n      });\n    }\n\n  }\n\n  P.on(document, \"click.bs.collapse.data-api\", '[data-bs-toggle=\"collapse\"]', function (t) {\n    (\"A\" === t.target.tagName || t.delegateTarget && \"A\" === t.delegateTarget.tagName) && t.preventDefault();\n    const i = e(this);\n    U.find(i).forEach(t => {\n      et.getOrCreateInstance(t, {\n        toggle: !1\n      }).toggle();\n    });\n  }), m(et);\n  var it = \"top\",\n      nt = \"bottom\",\n      st = \"right\",\n      ot = \"left\",\n      rt = [it, nt, st, ot],\n      at = rt.reduce(function (t, e) {\n    return t.concat([e + \"-start\", e + \"-end\"]);\n  }, []),\n      lt = [].concat(rt, [\"auto\"]).reduce(function (t, e) {\n    return t.concat([e, e + \"-start\", e + \"-end\"]);\n  }, []),\n      ct = [\"beforeRead\", \"read\", \"afterRead\", \"beforeMain\", \"main\", \"afterMain\", \"beforeWrite\", \"write\", \"afterWrite\"];\n\n  function ht(t) {\n    return t ? (t.nodeName || \"\").toLowerCase() : null;\n  }\n\n  function dt(t) {\n    if (null == t) return window;\n\n    if (\"[object Window]\" !== t.toString()) {\n      var e = t.ownerDocument;\n      return e && e.defaultView || window;\n    }\n\n    return t;\n  }\n\n  function ut(t) {\n    return t instanceof dt(t).Element || t instanceof Element;\n  }\n\n  function ft(t) {\n    return t instanceof dt(t).HTMLElement || t instanceof HTMLElement;\n  }\n\n  function pt(t) {\n    return \"undefined\" != typeof ShadowRoot && (t instanceof dt(t).ShadowRoot || t instanceof ShadowRoot);\n  }\n\n  var mt = {\n    name: \"applyStyles\",\n    enabled: !0,\n    phase: \"write\",\n    fn: function (t) {\n      var e = t.state;\n      Object.keys(e.elements).forEach(function (t) {\n        var i = e.styles[t] || {},\n            n = e.attributes[t] || {},\n            s = e.elements[t];\n        ft(s) && ht(s) && (Object.assign(s.style, i), Object.keys(n).forEach(function (t) {\n          var e = n[t];\n          !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? \"\" : e);\n        }));\n      });\n    },\n    effect: function (t) {\n      var e = t.state,\n          i = {\n        popper: {\n          position: e.options.strategy,\n          left: \"0\",\n          top: \"0\",\n          margin: \"0\"\n        },\n        arrow: {\n          position: \"absolute\"\n        },\n        reference: {}\n      };\n      return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow), function () {\n        Object.keys(e.elements).forEach(function (t) {\n          var n = e.elements[t],\n              s = e.attributes[t] || {},\n              o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce(function (t, e) {\n            return t[e] = \"\", t;\n          }, {});\n          ft(n) && ht(n) && (Object.assign(n.style, o), Object.keys(s).forEach(function (t) {\n            n.removeAttribute(t);\n          }));\n        });\n      };\n    },\n    requires: [\"computeStyles\"]\n  };\n\n  function gt(t) {\n    return t.split(\"-\")[0];\n  }\n\n  var _t = Math.round;\n\n  function bt(t, e) {\n    void 0 === e && (e = !1);\n    var i = t.getBoundingClientRect(),\n        n = 1,\n        s = 1;\n    return ft(t) && e && (n = i.width / t.offsetWidth || 1, s = i.height / t.offsetHeight || 1), {\n      width: _t(i.width / n),\n      height: _t(i.height / s),\n      top: _t(i.top / s),\n      right: _t(i.right / n),\n      bottom: _t(i.bottom / s),\n      left: _t(i.left / n),\n      x: _t(i.left / n),\n      y: _t(i.top / s)\n    };\n  }\n\n  function vt(t) {\n    var e = bt(t),\n        i = t.offsetWidth,\n        n = t.offsetHeight;\n    return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {\n      x: t.offsetLeft,\n      y: t.offsetTop,\n      width: i,\n      height: n\n    };\n  }\n\n  function yt(t, e) {\n    var i = e.getRootNode && e.getRootNode();\n    if (t.contains(e)) return !0;\n\n    if (i && pt(i)) {\n      var n = e;\n\n      do {\n        if (n && t.isSameNode(n)) return !0;\n        n = n.parentNode || n.host;\n      } while (n);\n    }\n\n    return !1;\n  }\n\n  function wt(t) {\n    return dt(t).getComputedStyle(t);\n  }\n\n  function Et(t) {\n    return [\"table\", \"td\", \"th\"].indexOf(ht(t)) >= 0;\n  }\n\n  function At(t) {\n    return ((ut(t) ? t.ownerDocument : t.document) || window.document).documentElement;\n  }\n\n  function Tt(t) {\n    return \"html\" === ht(t) ? t : t.assignedSlot || t.parentNode || (pt(t) ? t.host : null) || At(t);\n  }\n\n  function Ot(t) {\n    return ft(t) && \"fixed\" !== wt(t).position ? t.offsetParent : null;\n  }\n\n  function Ct(t) {\n    for (var e = dt(t), i = Ot(t); i && Et(i) && \"static\" === wt(i).position;) i = Ot(i);\n\n    return i && (\"html\" === ht(i) || \"body\" === ht(i) && \"static\" === wt(i).position) ? e : i || function (t) {\n      var e = -1 !== navigator.userAgent.toLowerCase().indexOf(\"firefox\");\n      if (-1 !== navigator.userAgent.indexOf(\"Trident\") && ft(t) && \"fixed\" === wt(t).position) return null;\n\n      for (var i = Tt(t); ft(i) && [\"html\", \"body\"].indexOf(ht(i)) < 0;) {\n        var n = wt(i);\n        if (\"none\" !== n.transform || \"none\" !== n.perspective || \"paint\" === n.contain || -1 !== [\"transform\", \"perspective\"].indexOf(n.willChange) || e && \"filter\" === n.willChange || e && n.filter && \"none\" !== n.filter) return i;\n        i = i.parentNode;\n      }\n\n      return null;\n    }(t) || e;\n  }\n\n  function kt(t) {\n    return [\"top\", \"bottom\"].indexOf(t) >= 0 ? \"x\" : \"y\";\n  }\n\n  var Lt = Math.max,\n      xt = Math.min,\n      Dt = Math.round;\n\n  function St(t, e, i) {\n    return Lt(t, xt(e, i));\n  }\n\n  function Nt(t) {\n    return Object.assign({}, {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }, t);\n  }\n\n  function It(t, e) {\n    return e.reduce(function (e, i) {\n      return e[i] = t, e;\n    }, {});\n  }\n\n  var Pt = {\n    name: \"arrow\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function (t) {\n      var e,\n          i = t.state,\n          n = t.name,\n          s = t.options,\n          o = i.elements.arrow,\n          r = i.modifiersData.popperOffsets,\n          a = gt(i.placement),\n          l = kt(a),\n          c = [ot, st].indexOf(a) >= 0 ? \"height\" : \"width\";\n\n      if (o && r) {\n        var h = function (t, e) {\n          return Nt(\"number\" != typeof (t = \"function\" == typeof t ? t(Object.assign({}, e.rects, {\n            placement: e.placement\n          })) : t) ? t : It(t, rt));\n        }(s.padding, i),\n            d = vt(o),\n            u = \"y\" === l ? it : ot,\n            f = \"y\" === l ? nt : st,\n            p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],\n            m = r[l] - i.rects.reference[l],\n            g = Ct(o),\n            _ = g ? \"y\" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,\n            b = p / 2 - m / 2,\n            v = h[u],\n            y = _ - d[c] - h[f],\n            w = _ / 2 - d[c] / 2 + b,\n            E = St(v, w, y),\n            A = l;\n\n        i.modifiersData[n] = ((e = {})[A] = E, e.centerOffset = E - w, e);\n      }\n    },\n    effect: function (t) {\n      var e = t.state,\n          i = t.options.element,\n          n = void 0 === i ? \"[data-popper-arrow]\" : i;\n      null != n && (\"string\" != typeof n || (n = e.elements.popper.querySelector(n))) && yt(e.elements.popper, n) && (e.elements.arrow = n);\n    },\n    requires: [\"popperOffsets\"],\n    requiresIfExists: [\"preventOverflow\"]\n  },\n      jt = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n  };\n\n  function Mt(t) {\n    var e,\n        i = t.popper,\n        n = t.popperRect,\n        s = t.placement,\n        o = t.offsets,\n        r = t.position,\n        a = t.gpuAcceleration,\n        l = t.adaptive,\n        c = t.roundOffsets,\n        h = !0 === c ? function (t) {\n      var e = t.x,\n          i = t.y,\n          n = window.devicePixelRatio || 1;\n      return {\n        x: Dt(Dt(e * n) / n) || 0,\n        y: Dt(Dt(i * n) / n) || 0\n      };\n    }(o) : \"function\" == typeof c ? c(o) : o,\n        d = h.x,\n        u = void 0 === d ? 0 : d,\n        f = h.y,\n        p = void 0 === f ? 0 : f,\n        m = o.hasOwnProperty(\"x\"),\n        g = o.hasOwnProperty(\"y\"),\n        _ = ot,\n        b = it,\n        v = window;\n\n    if (l) {\n      var y = Ct(i),\n          w = \"clientHeight\",\n          E = \"clientWidth\";\n      y === dt(i) && \"static\" !== wt(y = At(i)).position && (w = \"scrollHeight\", E = \"scrollWidth\"), y = y, s === it && (b = nt, p -= y[w] - n.height, p *= a ? 1 : -1), s === ot && (_ = st, u -= y[E] - n.width, u *= a ? 1 : -1);\n    }\n\n    var A,\n        T = Object.assign({\n      position: r\n    }, l && jt);\n    return a ? Object.assign({}, T, ((A = {})[b] = g ? \"0\" : \"\", A[_] = m ? \"0\" : \"\", A.transform = (v.devicePixelRatio || 1) < 2 ? \"translate(\" + u + \"px, \" + p + \"px)\" : \"translate3d(\" + u + \"px, \" + p + \"px, 0)\", A)) : Object.assign({}, T, ((e = {})[b] = g ? p + \"px\" : \"\", e[_] = m ? u + \"px\" : \"\", e.transform = \"\", e));\n  }\n\n  var Ht = {\n    name: \"computeStyles\",\n    enabled: !0,\n    phase: \"beforeWrite\",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = i.gpuAcceleration,\n          s = void 0 === n || n,\n          o = i.adaptive,\n          r = void 0 === o || o,\n          a = i.roundOffsets,\n          l = void 0 === a || a,\n          c = {\n        placement: gt(e.placement),\n        popper: e.elements.popper,\n        popperRect: e.rects.popper,\n        gpuAcceleration: s\n      };\n      null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, Mt(Object.assign({}, c, {\n        offsets: e.modifiersData.popperOffsets,\n        position: e.options.strategy,\n        adaptive: r,\n        roundOffsets: l\n      })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, Mt(Object.assign({}, c, {\n        offsets: e.modifiersData.arrow,\n        position: \"absolute\",\n        adaptive: !1,\n        roundOffsets: l\n      })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {\n        \"data-popper-placement\": e.placement\n      });\n    },\n    data: {}\n  },\n      Bt = {\n    passive: !0\n  },\n      Rt = {\n    name: \"eventListeners\",\n    enabled: !0,\n    phase: \"write\",\n    fn: function () {},\n    effect: function (t) {\n      var e = t.state,\n          i = t.instance,\n          n = t.options,\n          s = n.scroll,\n          o = void 0 === s || s,\n          r = n.resize,\n          a = void 0 === r || r,\n          l = dt(e.elements.popper),\n          c = [].concat(e.scrollParents.reference, e.scrollParents.popper);\n      return o && c.forEach(function (t) {\n        t.addEventListener(\"scroll\", i.update, Bt);\n      }), a && l.addEventListener(\"resize\", i.update, Bt), function () {\n        o && c.forEach(function (t) {\n          t.removeEventListener(\"scroll\", i.update, Bt);\n        }), a && l.removeEventListener(\"resize\", i.update, Bt);\n      };\n    },\n    data: {}\n  },\n      Wt = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  };\n\n  function zt(t) {\n    return t.replace(/left|right|bottom|top/g, function (t) {\n      return Wt[t];\n    });\n  }\n\n  var qt = {\n    start: \"end\",\n    end: \"start\"\n  };\n\n  function Ft(t) {\n    return t.replace(/start|end/g, function (t) {\n      return qt[t];\n    });\n  }\n\n  function Ut(t) {\n    var e = dt(t);\n    return {\n      scrollLeft: e.pageXOffset,\n      scrollTop: e.pageYOffset\n    };\n  }\n\n  function $t(t) {\n    return bt(At(t)).left + Ut(t).scrollLeft;\n  }\n\n  function Vt(t) {\n    var e = wt(t),\n        i = e.overflow,\n        n = e.overflowX,\n        s = e.overflowY;\n    return /auto|scroll|overlay|hidden/.test(i + s + n);\n  }\n\n  function Kt(t, e) {\n    var i;\n    void 0 === e && (e = []);\n\n    var n = function t(e) {\n      return [\"html\", \"body\", \"#document\"].indexOf(ht(e)) >= 0 ? e.ownerDocument.body : ft(e) && Vt(e) ? e : t(Tt(e));\n    }(t),\n        s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),\n        o = dt(n),\n        r = s ? [o].concat(o.visualViewport || [], Vt(n) ? n : []) : n,\n        a = e.concat(r);\n\n    return s ? a : a.concat(Kt(Tt(r)));\n  }\n\n  function Xt(t) {\n    return Object.assign({}, t, {\n      left: t.x,\n      top: t.y,\n      right: t.x + t.width,\n      bottom: t.y + t.height\n    });\n  }\n\n  function Yt(t, e) {\n    return \"viewport\" === e ? Xt(function (t) {\n      var e = dt(t),\n          i = At(t),\n          n = e.visualViewport,\n          s = i.clientWidth,\n          o = i.clientHeight,\n          r = 0,\n          a = 0;\n      return n && (s = n.width, o = n.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (r = n.offsetLeft, a = n.offsetTop)), {\n        width: s,\n        height: o,\n        x: r + $t(t),\n        y: a\n      };\n    }(t)) : ft(e) ? function (t) {\n      var e = bt(t);\n      return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;\n    }(e) : Xt(function (t) {\n      var e,\n          i = At(t),\n          n = Ut(t),\n          s = null == (e = t.ownerDocument) ? void 0 : e.body,\n          o = Lt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),\n          r = Lt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),\n          a = -n.scrollLeft + $t(t),\n          l = -n.scrollTop;\n      return \"rtl\" === wt(s || i).direction && (a += Lt(i.clientWidth, s ? s.clientWidth : 0) - o), {\n        width: o,\n        height: r,\n        x: a,\n        y: l\n      };\n    }(At(t)));\n  }\n\n  function Qt(t) {\n    return t.split(\"-\")[1];\n  }\n\n  function Gt(t) {\n    var e,\n        i = t.reference,\n        n = t.element,\n        s = t.placement,\n        o = s ? gt(s) : null,\n        r = s ? Qt(s) : null,\n        a = i.x + i.width / 2 - n.width / 2,\n        l = i.y + i.height / 2 - n.height / 2;\n\n    switch (o) {\n      case it:\n        e = {\n          x: a,\n          y: i.y - n.height\n        };\n        break;\n\n      case nt:\n        e = {\n          x: a,\n          y: i.y + i.height\n        };\n        break;\n\n      case st:\n        e = {\n          x: i.x + i.width,\n          y: l\n        };\n        break;\n\n      case ot:\n        e = {\n          x: i.x - n.width,\n          y: l\n        };\n        break;\n\n      default:\n        e = {\n          x: i.x,\n          y: i.y\n        };\n    }\n\n    var c = o ? kt(o) : null;\n\n    if (null != c) {\n      var h = \"y\" === c ? \"height\" : \"width\";\n\n      switch (r) {\n        case \"start\":\n          e[c] = e[c] - (i[h] / 2 - n[h] / 2);\n          break;\n\n        case \"end\":\n          e[c] = e[c] + (i[h] / 2 - n[h] / 2);\n      }\n    }\n\n    return e;\n  }\n\n  function Zt(t, e) {\n    void 0 === e && (e = {});\n\n    var i = e,\n        n = i.placement,\n        s = void 0 === n ? t.placement : n,\n        o = i.boundary,\n        r = void 0 === o ? \"clippingParents\" : o,\n        a = i.rootBoundary,\n        l = void 0 === a ? \"viewport\" : a,\n        c = i.elementContext,\n        h = void 0 === c ? \"popper\" : c,\n        d = i.altBoundary,\n        u = void 0 !== d && d,\n        f = i.padding,\n        p = void 0 === f ? 0 : f,\n        m = Nt(\"number\" != typeof p ? p : It(p, rt)),\n        g = \"popper\" === h ? \"reference\" : \"popper\",\n        _ = t.elements.reference,\n        b = t.rects.popper,\n        v = t.elements[u ? g : h],\n        y = function (t, e, i) {\n      var n = \"clippingParents\" === e ? function (t) {\n        var e = Kt(Tt(t)),\n            i = [\"absolute\", \"fixed\"].indexOf(wt(t).position) >= 0 && ft(t) ? Ct(t) : t;\n        return ut(i) ? e.filter(function (t) {\n          return ut(t) && yt(t, i) && \"body\" !== ht(t);\n        }) : [];\n      }(t) : [].concat(e),\n          s = [].concat(n, [i]),\n          o = s[0],\n          r = s.reduce(function (e, i) {\n        var n = Yt(t, i);\n        return e.top = Lt(n.top, e.top), e.right = xt(n.right, e.right), e.bottom = xt(n.bottom, e.bottom), e.left = Lt(n.left, e.left), e;\n      }, Yt(t, o));\n      return r.width = r.right - r.left, r.height = r.bottom - r.top, r.x = r.left, r.y = r.top, r;\n    }(ut(v) ? v : v.contextElement || At(t.elements.popper), r, l),\n        w = bt(_),\n        E = Gt({\n      reference: w,\n      element: b,\n      strategy: \"absolute\",\n      placement: s\n    }),\n        A = Xt(Object.assign({}, b, E)),\n        T = \"popper\" === h ? A : w,\n        O = {\n      top: y.top - T.top + m.top,\n      bottom: T.bottom - y.bottom + m.bottom,\n      left: y.left - T.left + m.left,\n      right: T.right - y.right + m.right\n    },\n        C = t.modifiersData.offset;\n\n    if (\"popper\" === h && C) {\n      var k = C[s];\n      Object.keys(O).forEach(function (t) {\n        var e = [st, nt].indexOf(t) >= 0 ? 1 : -1,\n            i = [it, nt].indexOf(t) >= 0 ? \"y\" : \"x\";\n        O[t] += k[i] * e;\n      });\n    }\n\n    return O;\n  }\n\n  function Jt(t, e) {\n    void 0 === e && (e = {});\n    var i = e,\n        n = i.placement,\n        s = i.boundary,\n        o = i.rootBoundary,\n        r = i.padding,\n        a = i.flipVariations,\n        l = i.allowedAutoPlacements,\n        c = void 0 === l ? lt : l,\n        h = Qt(n),\n        d = h ? a ? at : at.filter(function (t) {\n      return Qt(t) === h;\n    }) : rt,\n        u = d.filter(function (t) {\n      return c.indexOf(t) >= 0;\n    });\n    0 === u.length && (u = d);\n    var f = u.reduce(function (e, i) {\n      return e[i] = Zt(t, {\n        placement: i,\n        boundary: s,\n        rootBoundary: o,\n        padding: r\n      })[gt(i)], e;\n    }, {});\n    return Object.keys(f).sort(function (t, e) {\n      return f[t] - f[e];\n    });\n  }\n\n  var te = {\n    name: \"flip\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name;\n\n      if (!e.modifiersData[n]._skip) {\n        for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = gt(g), b = l || (_ !== g && p ? function (t) {\n          if (\"auto\" === gt(t)) return [];\n          var e = zt(t);\n          return [Ft(t), e, Ft(e)];\n        }(g) : [zt(g)]), v = [g].concat(b).reduce(function (t, i) {\n          return t.concat(\"auto\" === gt(i) ? Jt(e, {\n            placement: i,\n            boundary: h,\n            rootBoundary: d,\n            padding: c,\n            flipVariations: p,\n            allowedAutoPlacements: m\n          }) : i);\n        }, []), y = e.rects.reference, w = e.rects.popper, E = new Map(), A = !0, T = v[0], O = 0; O < v.length; O++) {\n          var C = v[O],\n              k = gt(C),\n              L = \"start\" === Qt(C),\n              x = [it, nt].indexOf(k) >= 0,\n              D = x ? \"width\" : \"height\",\n              S = Zt(e, {\n            placement: C,\n            boundary: h,\n            rootBoundary: d,\n            altBoundary: u,\n            padding: c\n          }),\n              N = x ? L ? st : ot : L ? nt : it;\n          y[D] > w[D] && (N = zt(N));\n          var I = zt(N),\n              P = [];\n\n          if (o && P.push(S[k] <= 0), a && P.push(S[N] <= 0, S[I] <= 0), P.every(function (t) {\n            return t;\n          })) {\n            T = C, A = !1;\n            break;\n          }\n\n          E.set(C, P);\n        }\n\n        if (A) for (var j = function (t) {\n          var e = v.find(function (e) {\n            var i = E.get(e);\n            if (i) return i.slice(0, t).every(function (t) {\n              return t;\n            });\n          });\n          if (e) return T = e, \"break\";\n        }, M = p ? 3 : 1; M > 0 && \"break\" !== j(M); M--);\n        e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0);\n      }\n    },\n    requiresIfExists: [\"offset\"],\n    data: {\n      _skip: !1\n    }\n  };\n\n  function ee(t, e, i) {\n    return void 0 === i && (i = {\n      x: 0,\n      y: 0\n    }), {\n      top: t.top - e.height - i.y,\n      right: t.right - e.width + i.x,\n      bottom: t.bottom - e.height + i.y,\n      left: t.left - e.width - i.x\n    };\n  }\n\n  function ie(t) {\n    return [it, st, nt, ot].some(function (e) {\n      return t[e] >= 0;\n    });\n  }\n\n  var ne = {\n    name: \"hide\",\n    enabled: !0,\n    phase: \"main\",\n    requiresIfExists: [\"preventOverflow\"],\n    fn: function (t) {\n      var e = t.state,\n          i = t.name,\n          n = e.rects.reference,\n          s = e.rects.popper,\n          o = e.modifiersData.preventOverflow,\n          r = Zt(e, {\n        elementContext: \"reference\"\n      }),\n          a = Zt(e, {\n        altBoundary: !0\n      }),\n          l = ee(r, n),\n          c = ee(a, s, o),\n          h = ie(l),\n          d = ie(c);\n      e.modifiersData[i] = {\n        referenceClippingOffsets: l,\n        popperEscapeOffsets: c,\n        isReferenceHidden: h,\n        hasPopperEscaped: d\n      }, e.attributes.popper = Object.assign({}, e.attributes.popper, {\n        \"data-popper-reference-hidden\": h,\n        \"data-popper-escaped\": d\n      });\n    }\n  },\n      se = {\n    name: \"offset\",\n    enabled: !0,\n    phase: \"main\",\n    requires: [\"popperOffsets\"],\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name,\n          s = i.offset,\n          o = void 0 === s ? [0, 0] : s,\n          r = lt.reduce(function (t, i) {\n        return t[i] = function (t, e, i) {\n          var n = gt(t),\n              s = [ot, it].indexOf(n) >= 0 ? -1 : 1,\n              o = \"function\" == typeof i ? i(Object.assign({}, e, {\n            placement: t\n          })) : i,\n              r = o[0],\n              a = o[1];\n          return r = r || 0, a = (a || 0) * s, [ot, st].indexOf(n) >= 0 ? {\n            x: a,\n            y: r\n          } : {\n            x: r,\n            y: a\n          };\n        }(i, e.rects, o), t;\n      }, {}),\n          a = r[e.placement],\n          l = a.x,\n          c = a.y;\n      null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r;\n    }\n  },\n      oe = {\n    name: \"popperOffsets\",\n    enabled: !0,\n    phase: \"read\",\n    fn: function (t) {\n      var e = t.state,\n          i = t.name;\n      e.modifiersData[i] = Gt({\n        reference: e.rects.reference,\n        element: e.rects.popper,\n        strategy: \"absolute\",\n        placement: e.placement\n      });\n    },\n    data: {}\n  },\n      re = {\n    name: \"preventOverflow\",\n    enabled: !0,\n    phase: \"main\",\n    fn: function (t) {\n      var e = t.state,\n          i = t.options,\n          n = t.name,\n          s = i.mainAxis,\n          o = void 0 === s || s,\n          r = i.altAxis,\n          a = void 0 !== r && r,\n          l = i.boundary,\n          c = i.rootBoundary,\n          h = i.altBoundary,\n          d = i.padding,\n          u = i.tether,\n          f = void 0 === u || u,\n          p = i.tetherOffset,\n          m = void 0 === p ? 0 : p,\n          g = Zt(e, {\n        boundary: l,\n        rootBoundary: c,\n        padding: d,\n        altBoundary: h\n      }),\n          _ = gt(e.placement),\n          b = Qt(e.placement),\n          v = !b,\n          y = kt(_),\n          w = \"x\" === y ? \"y\" : \"x\",\n          E = e.modifiersData.popperOffsets,\n          A = e.rects.reference,\n          T = e.rects.popper,\n          O = \"function\" == typeof m ? m(Object.assign({}, e.rects, {\n        placement: e.placement\n      })) : m,\n          C = {\n        x: 0,\n        y: 0\n      };\n\n      if (E) {\n        if (o || a) {\n          var k = \"y\" === y ? it : ot,\n              L = \"y\" === y ? nt : st,\n              x = \"y\" === y ? \"height\" : \"width\",\n              D = E[y],\n              S = E[y] + g[k],\n              N = E[y] - g[L],\n              I = f ? -T[x] / 2 : 0,\n              P = \"start\" === b ? A[x] : T[x],\n              j = \"start\" === b ? -T[x] : -A[x],\n              M = e.elements.arrow,\n              H = f && M ? vt(M) : {\n            width: 0,\n            height: 0\n          },\n              B = e.modifiersData[\"arrow#persistent\"] ? e.modifiersData[\"arrow#persistent\"].padding : {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n          },\n              R = B[k],\n              W = B[L],\n              z = St(0, A[x], H[x]),\n              q = v ? A[x] / 2 - I - z - R - O : P - z - R - O,\n              F = v ? -A[x] / 2 + I + z + W + O : j + z + W + O,\n              U = e.elements.arrow && Ct(e.elements.arrow),\n              $ = U ? \"y\" === y ? U.clientTop || 0 : U.clientLeft || 0 : 0,\n              V = e.modifiersData.offset ? e.modifiersData.offset[e.placement][y] : 0,\n              K = E[y] + q - V - $,\n              X = E[y] + F - V;\n\n          if (o) {\n            var Y = St(f ? xt(S, K) : S, D, f ? Lt(N, X) : N);\n            E[y] = Y, C[y] = Y - D;\n          }\n\n          if (a) {\n            var Q = \"x\" === y ? it : ot,\n                G = \"x\" === y ? nt : st,\n                Z = E[w],\n                J = Z + g[Q],\n                tt = Z - g[G],\n                et = St(f ? xt(J, K) : J, Z, f ? Lt(tt, X) : tt);\n            E[w] = et, C[w] = et - Z;\n          }\n        }\n\n        e.modifiersData[n] = C;\n      }\n    },\n    requiresIfExists: [\"offset\"]\n  };\n\n  function ae(t, e, i) {\n    void 0 === i && (i = !1);\n\n    var n,\n        s,\n        o = ft(e),\n        r = ft(e) && function (t) {\n      var e = t.getBoundingClientRect(),\n          i = e.width / t.offsetWidth || 1,\n          n = e.height / t.offsetHeight || 1;\n      return 1 !== i || 1 !== n;\n    }(e),\n        a = At(e),\n        l = bt(t, r),\n        c = {\n      scrollLeft: 0,\n      scrollTop: 0\n    },\n        h = {\n      x: 0,\n      y: 0\n    };\n\n    return (o || !o && !i) && ((\"body\" !== ht(e) || Vt(a)) && (c = (n = e) !== dt(n) && ft(n) ? {\n      scrollLeft: (s = n).scrollLeft,\n      scrollTop: s.scrollTop\n    } : Ut(n)), ft(e) ? ((h = bt(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = $t(a))), {\n      x: l.left + c.scrollLeft - h.x,\n      y: l.top + c.scrollTop - h.y,\n      width: l.width,\n      height: l.height\n    };\n  }\n\n  var le = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n  };\n\n  function ce() {\n    for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];\n\n    return !e.some(function (t) {\n      return !(t && \"function\" == typeof t.getBoundingClientRect);\n    });\n  }\n\n  function he(t) {\n    void 0 === t && (t = {});\n    var e = t,\n        i = e.defaultModifiers,\n        n = void 0 === i ? [] : i,\n        s = e.defaultOptions,\n        o = void 0 === s ? le : s;\n    return function (t, e, i) {\n      void 0 === i && (i = o);\n      var s,\n          r,\n          a = {\n        placement: \"bottom\",\n        orderedModifiers: [],\n        options: Object.assign({}, le, o),\n        modifiersData: {},\n        elements: {\n          reference: t,\n          popper: e\n        },\n        attributes: {},\n        styles: {}\n      },\n          l = [],\n          c = !1,\n          h = {\n        state: a,\n        setOptions: function (i) {\n          d(), a.options = Object.assign({}, o, a.options, i), a.scrollParents = {\n            reference: ut(t) ? Kt(t) : t.contextElement ? Kt(t.contextElement) : [],\n            popper: Kt(e)\n          };\n\n          var s,\n              r,\n              c = function (t) {\n            var e = function (t) {\n              var e = new Map(),\n                  i = new Set(),\n                  n = [];\n              return t.forEach(function (t) {\n                e.set(t.name, t);\n              }), t.forEach(function (t) {\n                i.has(t.name) || function t(s) {\n                  i.add(s.name), [].concat(s.requires || [], s.requiresIfExists || []).forEach(function (n) {\n                    if (!i.has(n)) {\n                      var s = e.get(n);\n                      s && t(s);\n                    }\n                  }), n.push(s);\n                }(t);\n              }), n;\n            }(t);\n\n            return ct.reduce(function (t, i) {\n              return t.concat(e.filter(function (t) {\n                return t.phase === i;\n              }));\n            }, []);\n          }((s = [].concat(n, a.options.modifiers), r = s.reduce(function (t, e) {\n            var i = t[e.name];\n            return t[e.name] = i ? Object.assign({}, i, e, {\n              options: Object.assign({}, i.options, e.options),\n              data: Object.assign({}, i.data, e.data)\n            }) : e, t;\n          }, {}), Object.keys(r).map(function (t) {\n            return r[t];\n          })));\n\n          return a.orderedModifiers = c.filter(function (t) {\n            return t.enabled;\n          }), a.orderedModifiers.forEach(function (t) {\n            var e = t.name,\n                i = t.options,\n                n = void 0 === i ? {} : i,\n                s = t.effect;\n\n            if (\"function\" == typeof s) {\n              var o = s({\n                state: a,\n                name: e,\n                instance: h,\n                options: n\n              });\n              l.push(o || function () {});\n            }\n          }), h.update();\n        },\n        forceUpdate: function () {\n          if (!c) {\n            var t = a.elements,\n                e = t.reference,\n                i = t.popper;\n\n            if (ce(e, i)) {\n              a.rects = {\n                reference: ae(e, Ct(i), \"fixed\" === a.options.strategy),\n                popper: vt(i)\n              }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach(function (t) {\n                return a.modifiersData[t.name] = Object.assign({}, t.data);\n              });\n\n              for (var n = 0; n < a.orderedModifiers.length; n++) if (!0 !== a.reset) {\n                var s = a.orderedModifiers[n],\n                    o = s.fn,\n                    r = s.options,\n                    l = void 0 === r ? {} : r,\n                    d = s.name;\n                \"function\" == typeof o && (a = o({\n                  state: a,\n                  options: l,\n                  name: d,\n                  instance: h\n                }) || a);\n              } else a.reset = !1, n = -1;\n            }\n          }\n        },\n        update: (s = function () {\n          return new Promise(function (t) {\n            h.forceUpdate(), t(a);\n          });\n        }, function () {\n          return r || (r = new Promise(function (t) {\n            Promise.resolve().then(function () {\n              r = void 0, t(s());\n            });\n          })), r;\n        }),\n        destroy: function () {\n          d(), c = !0;\n        }\n      };\n      if (!ce(t, e)) return h;\n\n      function d() {\n        l.forEach(function (t) {\n          return t();\n        }), l = [];\n      }\n\n      return h.setOptions(i).then(function (t) {\n        !c && i.onFirstUpdate && i.onFirstUpdate(t);\n      }), h;\n    };\n  }\n\n  var de = he(),\n      ue = he({\n    defaultModifiers: [Rt, oe, Ht, mt]\n  }),\n      fe = he({\n    defaultModifiers: [Rt, oe, Ht, mt, se, te, re, Pt, ne]\n  }),\n      pe = Object.freeze({\n    __proto__: null,\n    popperGenerator: he,\n    detectOverflow: Zt,\n    createPopperBase: de,\n    createPopper: fe,\n    createPopperLite: ue,\n    top: it,\n    bottom: nt,\n    right: st,\n    left: ot,\n    auto: \"auto\",\n    basePlacements: rt,\n    start: \"start\",\n    end: \"end\",\n    clippingParents: \"clippingParents\",\n    viewport: \"viewport\",\n    popper: \"popper\",\n    reference: \"reference\",\n    variationPlacements: at,\n    placements: lt,\n    beforeRead: \"beforeRead\",\n    read: \"read\",\n    afterRead: \"afterRead\",\n    beforeMain: \"beforeMain\",\n    main: \"main\",\n    afterMain: \"afterMain\",\n    beforeWrite: \"beforeWrite\",\n    write: \"write\",\n    afterWrite: \"afterWrite\",\n    modifierPhases: ct,\n    applyStyles: mt,\n    arrow: Pt,\n    computeStyles: Ht,\n    eventListeners: Rt,\n    flip: te,\n    hide: ne,\n    offset: se,\n    popperOffsets: oe,\n    preventOverflow: re\n  });\n\n  const me = new RegExp(\"ArrowUp|ArrowDown|Escape\"),\n        ge = p() ? \"top-end\" : \"top-start\",\n        _e = p() ? \"top-start\" : \"top-end\",\n        be = p() ? \"bottom-end\" : \"bottom-start\",\n        ve = p() ? \"bottom-start\" : \"bottom-end\",\n        ye = p() ? \"left-start\" : \"right-start\",\n        we = p() ? \"right-start\" : \"left-start\",\n        Ee = {\n    offset: [0, 2],\n    boundary: \"clippingParents\",\n    reference: \"toggle\",\n    display: \"dynamic\",\n    popperConfig: null,\n    autoClose: !0\n  },\n        Ae = {\n    offset: \"(array|string|function)\",\n    boundary: \"(string|element)\",\n    reference: \"(string|element|object)\",\n    display: \"string\",\n    popperConfig: \"(null|object|function)\",\n    autoClose: \"(boolean|string)\"\n  };\n\n  class Te extends H {\n    constructor(t, e) {\n      super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar();\n    }\n\n    static get Default() {\n      return Ee;\n    }\n\n    static get DefaultType() {\n      return Ae;\n    }\n\n    static get NAME() {\n      return \"dropdown\";\n    }\n\n    toggle() {\n      return this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (l(this._element) || this._isShown(this._menu)) return;\n      const t = {\n        relatedTarget: this._element\n      };\n      if (P.trigger(this._element, \"show.bs.dropdown\", t).defaultPrevented) return;\n      const e = Te.getParentFromElement(this._element);\n      this._inNavbar ? F.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(e), \"ontouchstart\" in document.documentElement && !e.closest(\".navbar-nav\") && [].concat(...document.body.children).forEach(t => P.on(t, \"mouseover\", h)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.classList.add(\"show\"), this._element.classList.add(\"show\"), P.trigger(this._element, \"shown.bs.dropdown\", t);\n    }\n\n    hide() {\n      if (l(this._element) || !this._isShown(this._menu)) return;\n      const t = {\n        relatedTarget: this._element\n      };\n\n      this._completeHide(t);\n    }\n\n    dispose() {\n      this._popper && this._popper.destroy(), super.dispose();\n    }\n\n    update() {\n      this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n    }\n\n    _completeHide(t) {\n      P.trigger(this._element, \"hide.bs.dropdown\", t).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach(t => P.off(t, \"mouseover\", h)), this._popper && this._popper.destroy(), this._menu.classList.remove(\"show\"), this._element.classList.remove(\"show\"), this._element.setAttribute(\"aria-expanded\", \"false\"), F.removeDataAttribute(this._menu, \"popper\"), P.trigger(this._element, \"hidden.bs.dropdown\", t));\n    }\n\n    _getConfig(t) {\n      if (t = { ...this.constructor.Default,\n        ...F.getDataAttributes(this._element),\n        ...t\n      }, r(\"dropdown\", t, this.constructor.DefaultType), \"object\" == typeof t.reference && !s(t.reference) && \"function\" != typeof t.reference.getBoundingClientRect) throw new TypeError(\"dropdown\".toUpperCase() + ': Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.');\n      return t;\n    }\n\n    _createPopper(t) {\n      if (void 0 === pe) throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n      let e = this._element;\n      \"parent\" === this._config.reference ? e = t : s(this._config.reference) ? e = o(this._config.reference) : \"object\" == typeof this._config.reference && (e = this._config.reference);\n\n      const i = this._getPopperConfig(),\n            n = i.modifiers.find(t => \"applyStyles\" === t.name && !1 === t.enabled);\n\n      this._popper = fe(e, this._menu, i), n && F.setDataAttribute(this._menu, \"popper\", \"static\");\n    }\n\n    _isShown(t = this._element) {\n      return t.classList.contains(\"show\");\n    }\n\n    _getMenuElement() {\n      return U.next(this._element, \".dropdown-menu\")[0];\n    }\n\n    _getPlacement() {\n      const t = this._element.parentNode;\n      if (t.classList.contains(\"dropend\")) return ye;\n      if (t.classList.contains(\"dropstart\")) return we;\n      const e = \"end\" === getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim();\n      return t.classList.contains(\"dropup\") ? e ? _e : ge : e ? ve : be;\n    }\n\n    _detectNavbar() {\n      return null !== this._element.closest(\".navbar\");\n    }\n\n    _getOffset() {\n      const {\n        offset: t\n      } = this._config;\n      return \"string\" == typeof t ? t.split(\",\").map(t => Number.parseInt(t, 10)) : \"function\" == typeof t ? e => t(e, this._element) : t;\n    }\n\n    _getPopperConfig() {\n      const t = {\n        placement: this._getPlacement(),\n        modifiers: [{\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }]\n      };\n      return \"static\" === this._config.display && (t.modifiers = [{\n        name: \"applyStyles\",\n        enabled: !1\n      }]), { ...t,\n        ...(\"function\" == typeof this._config.popperConfig ? this._config.popperConfig(t) : this._config.popperConfig)\n      };\n    }\n\n    _selectMenuItem({\n      key: t,\n      target: e\n    }) {\n      const i = U.find(\".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\", this._menu).filter(a);\n      i.length && b(i, e, \"ArrowDown\" === t, !i.includes(e)).focus();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = Te.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t]();\n        }\n      });\n    }\n\n    static clearMenus(t) {\n      if (t && (2 === t.button || \"keyup\" === t.type && \"Tab\" !== t.key)) return;\n      const e = U.find('[data-bs-toggle=\"dropdown\"]');\n\n      for (let i = 0, n = e.length; i < n; i++) {\n        const n = Te.getInstance(e[i]);\n        if (!n || !1 === n._config.autoClose) continue;\n        if (!n._isShown()) continue;\n        const s = {\n          relatedTarget: n._element\n        };\n\n        if (t) {\n          const e = t.composedPath(),\n                i = e.includes(n._menu);\n          if (e.includes(n._element) || \"inside\" === n._config.autoClose && !i || \"outside\" === n._config.autoClose && i) continue;\n          if (n._menu.contains(t.target) && (\"keyup\" === t.type && \"Tab\" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;\n          \"click\" === t.type && (s.clickEvent = t);\n        }\n\n        n._completeHide(s);\n      }\n    }\n\n    static getParentFromElement(t) {\n      return i(t) || t.parentNode;\n    }\n\n    static dataApiKeydownHandler(t) {\n      if (/input|textarea/i.test(t.target.tagName) ? \"Space\" === t.key || \"Escape\" !== t.key && (\"ArrowDown\" !== t.key && \"ArrowUp\" !== t.key || t.target.closest(\".dropdown-menu\")) : !me.test(t.key)) return;\n      const e = this.classList.contains(\"show\");\n      if (!e && \"Escape\" === t.key) return;\n      if (t.preventDefault(), t.stopPropagation(), l(this)) return;\n      const i = this.matches('[data-bs-toggle=\"dropdown\"]') ? this : U.prev(this, '[data-bs-toggle=\"dropdown\"]')[0],\n            n = Te.getOrCreateInstance(i);\n      if (\"Escape\" !== t.key) return \"ArrowUp\" === t.key || \"ArrowDown\" === t.key ? (e || n.show(), void n._selectMenuItem(t)) : void (e && \"Space\" !== t.key || Te.clearMenus());\n      n.hide();\n    }\n\n  }\n\n  P.on(document, \"keydown.bs.dropdown.data-api\", '[data-bs-toggle=\"dropdown\"]', Te.dataApiKeydownHandler), P.on(document, \"keydown.bs.dropdown.data-api\", \".dropdown-menu\", Te.dataApiKeydownHandler), P.on(document, \"click.bs.dropdown.data-api\", Te.clearMenus), P.on(document, \"keyup.bs.dropdown.data-api\", Te.clearMenus), P.on(document, \"click.bs.dropdown.data-api\", '[data-bs-toggle=\"dropdown\"]', function (t) {\n    t.preventDefault(), Te.getOrCreateInstance(this).toggle();\n  }), m(Te);\n\n  class Oe {\n    constructor() {\n      this._element = document.body;\n    }\n\n    getWidth() {\n      const t = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - t);\n    }\n\n    hide() {\n      const t = this.getWidth();\n      this._disableOverFlow(), this._setElementAttributes(this._element, \"paddingRight\", e => e + t), this._setElementAttributes(\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", \"paddingRight\", e => e + t), this._setElementAttributes(\".sticky-top\", \"marginRight\", e => e - t);\n    }\n\n    _disableOverFlow() {\n      this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\n    }\n\n    _setElementAttributes(t, e, i) {\n      const n = this.getWidth();\n\n      this._applyManipulationCallback(t, t => {\n        if (t !== this._element && window.innerWidth > t.clientWidth + n) return;\n\n        this._saveInitialAttribute(t, e);\n\n        const s = window.getComputedStyle(t)[e];\n        t.style[e] = i(Number.parseFloat(s)) + \"px\";\n      });\n    }\n\n    reset() {\n      this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(\".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", \"paddingRight\"), this._resetElementAttributes(\".sticky-top\", \"marginRight\");\n    }\n\n    _saveInitialAttribute(t, e) {\n      const i = t.style[e];\n      i && F.setDataAttribute(t, e, i);\n    }\n\n    _resetElementAttributes(t, e) {\n      this._applyManipulationCallback(t, t => {\n        const i = F.getDataAttribute(t, e);\n        void 0 === i ? t.style.removeProperty(e) : (F.removeDataAttribute(t, e), t.style[e] = i);\n      });\n    }\n\n    _applyManipulationCallback(t, e) {\n      s(t) ? e(t) : U.find(t, this._element).forEach(e);\n    }\n\n    isOverflowing() {\n      return this.getWidth() > 0;\n    }\n\n  }\n\n  const Ce = {\n    className: \"modal-backdrop\",\n    isVisible: !0,\n    isAnimated: !1,\n    rootElement: \"body\",\n    clickCallback: null\n  },\n        ke = {\n    className: \"string\",\n    isVisible: \"boolean\",\n    isAnimated: \"boolean\",\n    rootElement: \"(element|string)\",\n    clickCallback: \"(function|null)\"\n  };\n\n  class Le {\n    constructor(t) {\n      this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n    }\n\n    show(t) {\n      this._config.isVisible ? (this._append(), this._config.isAnimated && d(this._getElement()), this._getElement().classList.add(\"show\"), this._emulateAnimation(() => {\n        g(t);\n      })) : g(t);\n    }\n\n    hide(t) {\n      this._config.isVisible ? (this._getElement().classList.remove(\"show\"), this._emulateAnimation(() => {\n        this.dispose(), g(t);\n      })) : g(t);\n    }\n\n    _getElement() {\n      if (!this._element) {\n        const t = document.createElement(\"div\");\n        t.className = this._config.className, this._config.isAnimated && t.classList.add(\"fade\"), this._element = t;\n      }\n\n      return this._element;\n    }\n\n    _getConfig(t) {\n      return (t = { ...Ce,\n        ...(\"object\" == typeof t ? t : {})\n      }).rootElement = o(t.rootElement), r(\"backdrop\", t, ke), t;\n    }\n\n    _append() {\n      this._isAppended || (this._config.rootElement.append(this._getElement()), P.on(this._getElement(), \"mousedown.bs.backdrop\", () => {\n        g(this._config.clickCallback);\n      }), this._isAppended = !0);\n    }\n\n    dispose() {\n      this._isAppended && (P.off(this._element, \"mousedown.bs.backdrop\"), this._element.remove(), this._isAppended = !1);\n    }\n\n    _emulateAnimation(t) {\n      _(t, this._getElement(), this._config.isAnimated);\n    }\n\n  }\n\n  const xe = {\n    trapElement: null,\n    autofocus: !0\n  },\n        De = {\n    trapElement: \"element\",\n    autofocus: \"boolean\"\n  };\n\n  class Se {\n    constructor(t) {\n      this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null;\n    }\n\n    activate() {\n      const {\n        trapElement: t,\n        autofocus: e\n      } = this._config;\n      this._isActive || (e && t.focus(), P.off(document, \".bs.focustrap\"), P.on(document, \"focusin.bs.focustrap\", t => this._handleFocusin(t)), P.on(document, \"keydown.tab.bs.focustrap\", t => this._handleKeydown(t)), this._isActive = !0);\n    }\n\n    deactivate() {\n      this._isActive && (this._isActive = !1, P.off(document, \".bs.focustrap\"));\n    }\n\n    _handleFocusin(t) {\n      const {\n        target: e\n      } = t,\n            {\n        trapElement: i\n      } = this._config;\n      if (e === document || e === i || i.contains(e)) return;\n      const n = U.focusableChildren(i);\n      0 === n.length ? i.focus() : \"backward\" === this._lastTabNavDirection ? n[n.length - 1].focus() : n[0].focus();\n    }\n\n    _handleKeydown(t) {\n      \"Tab\" === t.key && (this._lastTabNavDirection = t.shiftKey ? \"backward\" : \"forward\");\n    }\n\n    _getConfig(t) {\n      return t = { ...xe,\n        ...(\"object\" == typeof t ? t : {})\n      }, r(\"focustrap\", t, De), t;\n    }\n\n  }\n\n  const Ne = {\n    backdrop: !0,\n    keyboard: !0,\n    focus: !0\n  },\n        Ie = {\n    backdrop: \"(boolean|string)\",\n    keyboard: \"boolean\",\n    focus: \"boolean\"\n  };\n\n  class Pe extends H {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._dialog = U.findOne(\".modal-dialog\", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new Oe();\n    }\n\n    static get Default() {\n      return Ne;\n    }\n\n    static get NAME() {\n      return \"modal\";\n    }\n\n    toggle(t) {\n      return this._isShown ? this.hide() : this.show(t);\n    }\n\n    show(t) {\n      this._isShown || this._isTransitioning || P.trigger(this._element, \"show.bs.modal\", {\n        relatedTarget: t\n      }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), this._scrollBar.hide(), document.body.classList.add(\"modal-open\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), P.on(this._dialog, \"mousedown.dismiss.bs.modal\", () => {\n        P.one(this._element, \"mouseup.dismiss.bs.modal\", t => {\n          t.target === this._element && (this._ignoreBackdropClick = !0);\n        });\n      }), this._showBackdrop(() => this._showElement(t)));\n    }\n\n    hide() {\n      if (!this._isShown || this._isTransitioning) return;\n      if (P.trigger(this._element, \"hide.bs.modal\").defaultPrevented) return;\n      this._isShown = !1;\n\n      const t = this._isAnimated();\n\n      t && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.deactivate(), this._element.classList.remove(\"show\"), P.off(this._element, \"click.dismiss.bs.modal\"), P.off(this._dialog, \"mousedown.dismiss.bs.modal\"), this._queueCallback(() => this._hideModal(), this._element, t);\n    }\n\n    dispose() {\n      [window, this._dialog].forEach(t => P.off(t, \".bs.modal\")), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();\n    }\n\n    handleUpdate() {\n      this._adjustDialog();\n    }\n\n    _initializeBackDrop() {\n      return new Le({\n        isVisible: Boolean(this._config.backdrop),\n        isAnimated: this._isAnimated()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new Se({\n        trapElement: this._element\n      });\n    }\n\n    _getConfig(t) {\n      return t = { ...Ne,\n        ...F.getDataAttributes(this._element),\n        ...(\"object\" == typeof t ? t : {})\n      }, r(\"modal\", t, Ie), t;\n    }\n\n    _showElement(t) {\n      const e = this._isAnimated(),\n            i = U.findOne(\".modal-body\", this._dialog);\n\n      this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.append(this._element), this._element.style.display = \"block\", this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.scrollTop = 0, i && (i.scrollTop = 0), e && d(this._element), this._element.classList.add(\"show\"), this._queueCallback(() => {\n        this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, P.trigger(this._element, \"shown.bs.modal\", {\n          relatedTarget: t\n        });\n      }, this._dialog, e);\n    }\n\n    _setEscapeEvent() {\n      this._isShown ? P.on(this._element, \"keydown.dismiss.bs.modal\", t => {\n        this._config.keyboard && \"Escape\" === t.key ? (t.preventDefault(), this.hide()) : this._config.keyboard || \"Escape\" !== t.key || this._triggerBackdropTransition();\n      }) : P.off(this._element, \"keydown.dismiss.bs.modal\");\n    }\n\n    _setResizeEvent() {\n      this._isShown ? P.on(window, \"resize.bs.modal\", () => this._adjustDialog()) : P.off(window, \"resize.bs.modal\");\n    }\n\n    _hideModal() {\n      this._element.style.display = \"none\", this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop.hide(() => {\n        document.body.classList.remove(\"modal-open\"), this._resetAdjustments(), this._scrollBar.reset(), P.trigger(this._element, \"hidden.bs.modal\");\n      });\n    }\n\n    _showBackdrop(t) {\n      P.on(this._element, \"click.dismiss.bs.modal\", t => {\n        this._ignoreBackdropClick ? this._ignoreBackdropClick = !1 : t.target === t.currentTarget && (!0 === this._config.backdrop ? this.hide() : \"static\" === this._config.backdrop && this._triggerBackdropTransition());\n      }), this._backdrop.show(t);\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains(\"fade\");\n    }\n\n    _triggerBackdropTransition() {\n      if (P.trigger(this._element, \"hidePrevented.bs.modal\").defaultPrevented) return;\n      const {\n        classList: t,\n        scrollHeight: e,\n        style: i\n      } = this._element,\n            n = e > document.documentElement.clientHeight;\n      !n && \"hidden\" === i.overflowY || t.contains(\"modal-static\") || (n || (i.overflowY = \"hidden\"), t.add(\"modal-static\"), this._queueCallback(() => {\n        t.remove(\"modal-static\"), n || this._queueCallback(() => {\n          i.overflowY = \"\";\n        }, this._dialog);\n      }, this._dialog), this._element.focus());\n    }\n\n    _adjustDialog() {\n      const t = this._element.scrollHeight > document.documentElement.clientHeight,\n            e = this._scrollBar.getWidth(),\n            i = e > 0;\n\n      (!i && t && !p() || i && !t && p()) && (this._element.style.paddingLeft = e + \"px\"), (i && !t && !p() || !i && t && p()) && (this._element.style.paddingRight = e + \"px\");\n    }\n\n    _resetAdjustments() {\n      this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n    }\n\n    static jQueryInterface(t, e) {\n      return this.each(function () {\n        const i = Pe.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === i[t]) throw new TypeError(`No method named \"${t}\"`);\n          i[t](e);\n        }\n      });\n    }\n\n  }\n\n  P.on(document, \"click.bs.modal.data-api\", '[data-bs-toggle=\"modal\"]', function (t) {\n    const e = i(this);\n    [\"A\", \"AREA\"].includes(this.tagName) && t.preventDefault(), P.one(e, \"show.bs.modal\", t => {\n      t.defaultPrevented || P.one(e, \"hidden.bs.modal\", () => {\n        a(this) && this.focus();\n      });\n    }), Pe.getOrCreateInstance(e).toggle(this);\n  }), B(Pe), m(Pe);\n  const je = {\n    backdrop: !0,\n    keyboard: !0,\n    scroll: !1\n  },\n        Me = {\n    backdrop: \"boolean\",\n    keyboard: \"boolean\",\n    scroll: \"boolean\"\n  };\n\n  class He extends H {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();\n    }\n\n    static get NAME() {\n      return \"offcanvas\";\n    }\n\n    static get Default() {\n      return je;\n    }\n\n    toggle(t) {\n      return this._isShown ? this.hide() : this.show(t);\n    }\n\n    show(t) {\n      this._isShown || P.trigger(this._element, \"show.bs.offcanvas\", {\n        relatedTarget: t\n      }).defaultPrevented || (this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new Oe().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.classList.add(\"show\"), this._queueCallback(() => {\n        this._config.scroll || this._focustrap.activate(), P.trigger(this._element, \"shown.bs.offcanvas\", {\n          relatedTarget: t\n        });\n      }, this._element, !0));\n    }\n\n    hide() {\n      this._isShown && (P.trigger(this._element, \"hide.bs.offcanvas\").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.remove(\"show\"), this._backdrop.hide(), this._queueCallback(() => {\n        this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new Oe().reset(), P.trigger(this._element, \"hidden.bs.offcanvas\");\n      }, this._element, !0)));\n    }\n\n    dispose() {\n      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();\n    }\n\n    _getConfig(t) {\n      return t = { ...je,\n        ...F.getDataAttributes(this._element),\n        ...(\"object\" == typeof t ? t : {})\n      }, r(\"offcanvas\", t, Me), t;\n    }\n\n    _initializeBackDrop() {\n      return new Le({\n        className: \"offcanvas-backdrop\",\n        isVisible: this._config.backdrop,\n        isAnimated: !0,\n        rootElement: this._element.parentNode,\n        clickCallback: () => this.hide()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new Se({\n        trapElement: this._element\n      });\n    }\n\n    _addEventListeners() {\n      P.on(this._element, \"keydown.dismiss.bs.offcanvas\", t => {\n        this._config.keyboard && \"Escape\" === t.key && this.hide();\n      });\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = He.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t] || t.startsWith(\"_\") || \"constructor\" === t) throw new TypeError(`No method named \"${t}\"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  P.on(document, \"click.bs.offcanvas.data-api\", '[data-bs-toggle=\"offcanvas\"]', function (t) {\n    const e = i(this);\n    if ([\"A\", \"AREA\"].includes(this.tagName) && t.preventDefault(), l(this)) return;\n    P.one(e, \"hidden.bs.offcanvas\", () => {\n      a(this) && this.focus();\n    });\n    const n = U.findOne(\".offcanvas.show\");\n    n && n !== e && He.getInstance(n).hide(), He.getOrCreateInstance(e).toggle(this);\n  }), P.on(window, \"load.bs.offcanvas.data-api\", () => U.find(\".offcanvas.show\").forEach(t => He.getOrCreateInstance(t).show())), B(He), m(He);\n\n  const Be = new Set([\"background\", \"cite\", \"href\", \"itemtype\", \"longdesc\", \"poster\", \"src\", \"xlink:href\"]),\n        Re = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/i,\n        We = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n        ze = (t, e) => {\n    const i = t.nodeName.toLowerCase();\n    if (e.includes(i)) return !Be.has(i) || Boolean(Re.test(t.nodeValue) || We.test(t.nodeValue));\n    const n = e.filter(t => t instanceof RegExp);\n\n    for (let t = 0, e = n.length; t < e; t++) if (n[t].test(i)) return !0;\n\n    return !1;\n  };\n\n  function qe(t, e, i) {\n    if (!t.length) return t;\n    if (i && \"function\" == typeof i) return i(t);\n    const n = new window.DOMParser().parseFromString(t, \"text/html\"),\n          s = Object.keys(e),\n          o = [].concat(...n.body.querySelectorAll(\"*\"));\n\n    for (let t = 0, i = o.length; t < i; t++) {\n      const i = o[t],\n            n = i.nodeName.toLowerCase();\n\n      if (!s.includes(n)) {\n        i.remove();\n        continue;\n      }\n\n      const r = [].concat(...i.attributes),\n            a = [].concat(e[\"*\"] || [], e[n] || []);\n      r.forEach(t => {\n        ze(t, a) || i.removeAttribute(t.nodeName);\n      });\n    }\n\n    return n.body.innerHTML;\n  }\n\n  const Fe = new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]),\n        Ue = {\n    animation: \"boolean\",\n    template: \"string\",\n    title: \"(string|element|function)\",\n    trigger: \"string\",\n    delay: \"(number|object)\",\n    html: \"boolean\",\n    selector: \"(string|boolean)\",\n    placement: \"(string|function)\",\n    offset: \"(array|string|function)\",\n    container: \"(string|element|boolean)\",\n    fallbackPlacements: \"array\",\n    boundary: \"(string|element)\",\n    customClass: \"(string|function)\",\n    sanitize: \"boolean\",\n    sanitizeFn: \"(null|function)\",\n    allowList: \"object\",\n    popperConfig: \"(null|object|function)\"\n  },\n        $e = {\n    AUTO: \"auto\",\n    TOP: \"top\",\n    RIGHT: p() ? \"left\" : \"right\",\n    BOTTOM: \"bottom\",\n    LEFT: p() ? \"right\" : \"left\"\n  },\n        Ve = {\n    animation: !0,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: \"hover focus\",\n    title: \"\",\n    delay: 0,\n    html: !1,\n    selector: !1,\n    placement: \"top\",\n    offset: [0, 0],\n    container: !1,\n    fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\n    boundary: \"clippingParents\",\n    customClass: \"\",\n    sanitize: !0,\n    sanitizeFn: null,\n    allowList: {\n      \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", /^aria-[\\w-]*$/i],\n      a: [\"target\", \"href\", \"title\", \"rel\"],\n      area: [],\n      b: [],\n      br: [],\n      col: [],\n      code: [],\n      div: [],\n      em: [],\n      hr: [],\n      h1: [],\n      h2: [],\n      h3: [],\n      h4: [],\n      h5: [],\n      h6: [],\n      i: [],\n      img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n      li: [],\n      ol: [],\n      p: [],\n      pre: [],\n      s: [],\n      small: [],\n      span: [],\n      sub: [],\n      sup: [],\n      strong: [],\n      u: [],\n      ul: []\n    },\n    popperConfig: null\n  },\n        Ke = {\n    HIDE: \"hide.bs.tooltip\",\n    HIDDEN: \"hidden.bs.tooltip\",\n    SHOW: \"show.bs.tooltip\",\n    SHOWN: \"shown.bs.tooltip\",\n    INSERTED: \"inserted.bs.tooltip\",\n    CLICK: \"click.bs.tooltip\",\n    FOCUSIN: \"focusin.bs.tooltip\",\n    FOCUSOUT: \"focusout.bs.tooltip\",\n    MOUSEENTER: \"mouseenter.bs.tooltip\",\n    MOUSELEAVE: \"mouseleave.bs.tooltip\"\n  };\n\n  class Xe extends H {\n    constructor(t, e) {\n      if (void 0 === pe) throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n      super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n    }\n\n    static get Default() {\n      return Ve;\n    }\n\n    static get NAME() {\n      return \"tooltip\";\n    }\n\n    static get Event() {\n      return Ke;\n    }\n\n    static get DefaultType() {\n      return Ue;\n    }\n\n    enable() {\n      this._isEnabled = !0;\n    }\n\n    disable() {\n      this._isEnabled = !1;\n    }\n\n    toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    }\n\n    toggle(t) {\n      if (this._isEnabled) if (t) {\n        const e = this._initializeOnDelegatedTarget(t);\n\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n      } else {\n        if (this.getTipElement().classList.contains(\"show\")) return void this._leave(null, this);\n\n        this._enter(null, this);\n      }\n    }\n\n    dispose() {\n      clearTimeout(this._timeout), P.off(this._element.closest(\".modal\"), \"hide.bs.modal\", this._hideModalHandler), this.tip && this.tip.remove(), this._popper && this._popper.destroy(), super.dispose();\n    }\n\n    show() {\n      if (\"none\" === this._element.style.display) throw new Error(\"Please use show on visible elements\");\n      if (!this.isWithContent() || !this._isEnabled) return;\n      const t = P.trigger(this._element, this.constructor.Event.SHOW),\n            e = c(this._element),\n            i = null === e ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n      if (t.defaultPrevented || !i) return;\n\n      const n = this.getTipElement(),\n            s = (t => {\n        do {\n          t += Math.floor(1e6 * Math.random());\n        } while (document.getElementById(t));\n\n        return t;\n      })(this.constructor.NAME);\n\n      n.setAttribute(\"id\", s), this._element.setAttribute(\"aria-describedby\", s), this._config.animation && n.classList.add(\"fade\");\n\n      const o = \"function\" == typeof this._config.placement ? this._config.placement.call(this, n, this._element) : this._config.placement,\n            r = this._getAttachment(o);\n\n      this._addAttachmentClass(r);\n\n      const {\n        container: a\n      } = this._config;\n      M.set(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (a.append(n), P.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = fe(this._element, n, this._getPopperConfig(r)), n.classList.add(\"show\");\n\n      const l = this._resolvePossibleFunction(this._config.customClass);\n\n      l && n.classList.add(...l.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach(t => {\n        P.on(t, \"mouseover\", h);\n      });\n      const d = this.tip.classList.contains(\"fade\");\n\n      this._queueCallback(() => {\n        const t = this._hoverState;\n        this._hoverState = null, P.trigger(this._element, this.constructor.Event.SHOWN), \"out\" === t && this._leave(null, this);\n      }, this.tip, d);\n    }\n\n    hide() {\n      if (!this._popper) return;\n      const t = this.getTipElement();\n      if (P.trigger(this._element, this.constructor.Event.HIDE).defaultPrevented) return;\n      t.classList.remove(\"show\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach(t => P.off(t, \"mouseover\", h)), this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1;\n      const e = this.tip.classList.contains(\"fade\");\n      this._queueCallback(() => {\n        this._isWithActiveTrigger() || (\"show\" !== this._hoverState && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), P.trigger(this._element, this.constructor.Event.HIDDEN), this._popper && (this._popper.destroy(), this._popper = null));\n      }, this.tip, e), this._hoverState = \"\";\n    }\n\n    update() {\n      null !== this._popper && this._popper.update();\n    }\n\n    isWithContent() {\n      return Boolean(this.getTitle());\n    }\n\n    getTipElement() {\n      if (this.tip) return this.tip;\n      const t = document.createElement(\"div\");\n      t.innerHTML = this._config.template;\n      const e = t.children[0];\n      return this.setContent(e), e.classList.remove(\"fade\", \"show\"), this.tip = e, this.tip;\n    }\n\n    setContent(t) {\n      this._sanitizeAndSetContent(t, this.getTitle(), \".tooltip-inner\");\n    }\n\n    _sanitizeAndSetContent(t, e, i) {\n      const n = U.findOne(i, t);\n      e || !n ? this.setElementContent(n, e) : n.remove();\n    }\n\n    setElementContent(t, e) {\n      if (null !== t) return s(e) ? (e = o(e), void (this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent)) : void (this._config.html ? (this._config.sanitize && (e = qe(e, this._config.allowList, this._config.sanitizeFn)), t.innerHTML = e) : t.textContent = e);\n    }\n\n    getTitle() {\n      const t = this._element.getAttribute(\"data-bs-original-title\") || this._config.title;\n\n      return this._resolvePossibleFunction(t);\n    }\n\n    updateAttachment(t) {\n      return \"right\" === t ? \"end\" : \"left\" === t ? \"start\" : t;\n    }\n\n    _initializeOnDelegatedTarget(t, e) {\n      return e || this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig());\n    }\n\n    _getOffset() {\n      const {\n        offset: t\n      } = this._config;\n      return \"string\" == typeof t ? t.split(\",\").map(t => Number.parseInt(t, 10)) : \"function\" == typeof t ? e => t(e, this._element) : t;\n    }\n\n    _resolvePossibleFunction(t) {\n      return \"function\" == typeof t ? t.call(this._element) : t;\n    }\n\n    _getPopperConfig(t) {\n      const e = {\n        placement: t,\n        modifiers: [{\n          name: \"flip\",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        }, {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }, {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: \"arrow\",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        }, {\n          name: \"onChange\",\n          enabled: !0,\n          phase: \"afterWrite\",\n          fn: t => this._handlePopperPlacementChange(t)\n        }],\n        onFirstUpdate: t => {\n          t.options.placement !== t.placement && this._handlePopperPlacementChange(t);\n        }\n      };\n      return { ...e,\n        ...(\"function\" == typeof this._config.popperConfig ? this._config.popperConfig(e) : this._config.popperConfig)\n      };\n    }\n\n    _addAttachmentClass(t) {\n      this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`);\n    }\n\n    _getAttachment(t) {\n      return $e[t.toUpperCase()];\n    }\n\n    _setListeners() {\n      this._config.trigger.split(\" \").forEach(t => {\n        if (\"click\" === t) P.on(this._element, this.constructor.Event.CLICK, this._config.selector, t => this.toggle(t));else if (\"manual\" !== t) {\n          const e = \"hover\" === t ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN,\n                i = \"hover\" === t ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n          P.on(this._element, e, this._config.selector, t => this._enter(t)), P.on(this._element, i, this._config.selector, t => this._leave(t));\n        }\n      }), this._hideModalHandler = () => {\n        this._element && this.hide();\n      }, P.on(this._element.closest(\".modal\"), \"hide.bs.modal\", this._hideModalHandler), this._config.selector ? this._config = { ...this._config,\n        trigger: \"manual\",\n        selector: \"\"\n      } : this._fixTitle();\n    }\n\n    _fixTitle() {\n      const t = this._element.getAttribute(\"title\"),\n            e = typeof this._element.getAttribute(\"data-bs-original-title\");\n\n      (t || \"string\" !== e) && (this._element.setAttribute(\"data-bs-original-title\", t || \"\"), !t || this._element.getAttribute(\"aria-label\") || this._element.textContent || this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n    }\n\n    _enter(t, e) {\n      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[\"focusin\" === t.type ? \"focus\" : \"hover\"] = !0), e.getTipElement().classList.contains(\"show\") || \"show\" === e._hoverState ? e._hoverState = \"show\" : (clearTimeout(e._timeout), e._hoverState = \"show\", e._config.delay && e._config.delay.show ? e._timeout = setTimeout(() => {\n        \"show\" === e._hoverState && e.show();\n      }, e._config.delay.show) : e.show());\n    }\n\n    _leave(t, e) {\n      e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[\"focusout\" === t.type ? \"focus\" : \"hover\"] = e._element.contains(t.relatedTarget)), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = \"out\", e._config.delay && e._config.delay.hide ? e._timeout = setTimeout(() => {\n        \"out\" === e._hoverState && e.hide();\n      }, e._config.delay.hide) : e.hide());\n    }\n\n    _isWithActiveTrigger() {\n      for (const t in this._activeTrigger) if (this._activeTrigger[t]) return !0;\n\n      return !1;\n    }\n\n    _getConfig(t) {\n      const e = F.getDataAttributes(this._element);\n      return Object.keys(e).forEach(t => {\n        Fe.has(t) && delete e[t];\n      }), (t = { ...this.constructor.Default,\n        ...e,\n        ...(\"object\" == typeof t && t ? t : {})\n      }).container = !1 === t.container ? document.body : o(t.container), \"number\" == typeof t.delay && (t.delay = {\n        show: t.delay,\n        hide: t.delay\n      }), \"number\" == typeof t.title && (t.title = t.title.toString()), \"number\" == typeof t.content && (t.content = t.content.toString()), r(\"tooltip\", t, this.constructor.DefaultType), t.sanitize && (t.template = qe(t.template, t.allowList, t.sanitizeFn)), t;\n    }\n\n    _getDelegateConfig() {\n      const t = {};\n\n      for (const e in this._config) this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n\n      return t;\n    }\n\n    _cleanTipClass() {\n      const t = this.getTipElement(),\n            e = new RegExp(`(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`, \"g\"),\n            i = t.getAttribute(\"class\").match(e);\n      null !== i && i.length > 0 && i.map(t => t.trim()).forEach(e => t.classList.remove(e));\n    }\n\n    _getBasicClassPrefix() {\n      return \"bs-tooltip\";\n    }\n\n    _handlePopperPlacementChange(t) {\n      const {\n        state: e\n      } = t;\n      e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = Xe.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  m(Xe);\n  const Ye = { ...Xe.Default,\n    placement: \"right\",\n    offset: [0, 8],\n    trigger: \"click\",\n    content: \"\",\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"popover-arrow\"></div><h3 class=\"popover-header\"></h3><div class=\"popover-body\"></div></div>'\n  },\n        Qe = { ...Xe.DefaultType,\n    content: \"(string|element|function)\"\n  },\n        Ge = {\n    HIDE: \"hide.bs.popover\",\n    HIDDEN: \"hidden.bs.popover\",\n    SHOW: \"show.bs.popover\",\n    SHOWN: \"shown.bs.popover\",\n    INSERTED: \"inserted.bs.popover\",\n    CLICK: \"click.bs.popover\",\n    FOCUSIN: \"focusin.bs.popover\",\n    FOCUSOUT: \"focusout.bs.popover\",\n    MOUSEENTER: \"mouseenter.bs.popover\",\n    MOUSELEAVE: \"mouseleave.bs.popover\"\n  };\n\n  class Ze extends Xe {\n    static get Default() {\n      return Ye;\n    }\n\n    static get NAME() {\n      return \"popover\";\n    }\n\n    static get Event() {\n      return Ge;\n    }\n\n    static get DefaultType() {\n      return Qe;\n    }\n\n    isWithContent() {\n      return this.getTitle() || this._getContent();\n    }\n\n    setContent(t) {\n      this._sanitizeAndSetContent(t, this.getTitle(), \".popover-header\"), this._sanitizeAndSetContent(t, this._getContent(), \".popover-body\");\n    }\n\n    _getContent() {\n      return this._resolvePossibleFunction(this._config.content);\n    }\n\n    _getBasicClassPrefix() {\n      return \"bs-popover\";\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = Ze.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  m(Ze);\n  const Je = {\n    offset: 10,\n    method: \"auto\",\n    target: \"\"\n  },\n        ti = {\n    offset: \"number\",\n    method: \"string\",\n    target: \"(string|element)\"\n  },\n        ei = \".nav-link, .list-group-item, .dropdown-item\";\n\n  class ii extends H {\n    constructor(t, e) {\n      super(t), this._scrollElement = \"BODY\" === this._element.tagName ? window : this._element, this._config = this._getConfig(e), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, P.on(this._scrollElement, \"scroll.bs.scrollspy\", () => this._process()), this.refresh(), this._process();\n    }\n\n    static get Default() {\n      return Je;\n    }\n\n    static get NAME() {\n      return \"scrollspy\";\n    }\n\n    refresh() {\n      const t = this._scrollElement === this._scrollElement.window ? \"offset\" : \"position\",\n            i = \"auto\" === this._config.method ? t : this._config.method,\n            n = \"position\" === i ? this._getScrollTop() : 0;\n      this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), U.find(ei, this._config.target).map(t => {\n        const s = e(t),\n              o = s ? U.findOne(s) : null;\n\n        if (o) {\n          const t = o.getBoundingClientRect();\n          if (t.width || t.height) return [F[i](o).top + n, s];\n        }\n\n        return null;\n      }).filter(t => t).sort((t, e) => t[0] - e[0]).forEach(t => {\n        this._offsets.push(t[0]), this._targets.push(t[1]);\n      });\n    }\n\n    dispose() {\n      P.off(this._scrollElement, \".bs.scrollspy\"), super.dispose();\n    }\n\n    _getConfig(t) {\n      return (t = { ...Je,\n        ...F.getDataAttributes(this._element),\n        ...(\"object\" == typeof t && t ? t : {})\n      }).target = o(t.target) || document.documentElement, r(\"scrollspy\", t, ti), t;\n    }\n\n    _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    }\n\n    _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    }\n\n    _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    }\n\n    _process() {\n      const t = this._getScrollTop() + this._config.offset,\n            e = this._getScrollHeight(),\n            i = this._config.offset + e - this._getOffsetHeight();\n\n      if (this._scrollHeight !== e && this.refresh(), t >= i) {\n        const t = this._targets[this._targets.length - 1];\n        this._activeTarget !== t && this._activate(t);\n      } else {\n        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();\n\n        for (let e = this._offsets.length; e--;) this._activeTarget !== this._targets[e] && t >= this._offsets[e] && (void 0 === this._offsets[e + 1] || t < this._offsets[e + 1]) && this._activate(this._targets[e]);\n      }\n    }\n\n    _activate(t) {\n      this._activeTarget = t, this._clear();\n      const e = ei.split(\",\").map(e => `${e}[data-bs-target=\"${t}\"],${e}[href=\"${t}\"]`),\n            i = U.findOne(e.join(\",\"), this._config.target);\n      i.classList.add(\"active\"), i.classList.contains(\"dropdown-item\") ? U.findOne(\".dropdown-toggle\", i.closest(\".dropdown\")).classList.add(\"active\") : U.parents(i, \".nav, .list-group\").forEach(t => {\n        U.prev(t, \".nav-link, .list-group-item\").forEach(t => t.classList.add(\"active\")), U.prev(t, \".nav-item\").forEach(t => {\n          U.children(t, \".nav-link\").forEach(t => t.classList.add(\"active\"));\n        });\n      }), P.trigger(this._scrollElement, \"activate.bs.scrollspy\", {\n        relatedTarget: t\n      });\n    }\n\n    _clear() {\n      U.find(ei, this._config.target).filter(t => t.classList.contains(\"active\")).forEach(t => t.classList.remove(\"active\"));\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = ii.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  P.on(window, \"load.bs.scrollspy.data-api\", () => {\n    U.find('[data-bs-spy=\"scroll\"]').forEach(t => new ii(t));\n  }), m(ii);\n\n  class ni extends H {\n    static get NAME() {\n      return \"tab\";\n    }\n\n    show() {\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(\"active\")) return;\n      let t;\n\n      const e = i(this._element),\n            n = this._element.closest(\".nav, .list-group\");\n\n      if (n) {\n        const e = \"UL\" === n.nodeName || \"OL\" === n.nodeName ? \":scope > li > .active\" : \".active\";\n        t = U.find(e, n), t = t[t.length - 1];\n      }\n\n      const s = t ? P.trigger(t, \"hide.bs.tab\", {\n        relatedTarget: this._element\n      }) : null;\n      if (P.trigger(this._element, \"show.bs.tab\", {\n        relatedTarget: t\n      }).defaultPrevented || null !== s && s.defaultPrevented) return;\n\n      this._activate(this._element, n);\n\n      const o = () => {\n        P.trigger(t, \"hidden.bs.tab\", {\n          relatedTarget: this._element\n        }), P.trigger(this._element, \"shown.bs.tab\", {\n          relatedTarget: t\n        });\n      };\n\n      e ? this._activate(e, e.parentNode, o) : o();\n    }\n\n    _activate(t, e, i) {\n      const n = (!e || \"UL\" !== e.nodeName && \"OL\" !== e.nodeName ? U.children(e, \".active\") : U.find(\":scope > li > .active\", e))[0],\n            s = i && n && n.classList.contains(\"fade\"),\n            o = () => this._transitionComplete(t, n, i);\n\n      n && s ? (n.classList.remove(\"show\"), this._queueCallback(o, t, !0)) : o();\n    }\n\n    _transitionComplete(t, e, i) {\n      if (e) {\n        e.classList.remove(\"active\");\n        const t = U.findOne(\":scope > .dropdown-menu .active\", e.parentNode);\n        t && t.classList.remove(\"active\"), \"tab\" === e.getAttribute(\"role\") && e.setAttribute(\"aria-selected\", !1);\n      }\n\n      t.classList.add(\"active\"), \"tab\" === t.getAttribute(\"role\") && t.setAttribute(\"aria-selected\", !0), d(t), t.classList.contains(\"fade\") && t.classList.add(\"show\");\n      let n = t.parentNode;\n\n      if (n && \"LI\" === n.nodeName && (n = n.parentNode), n && n.classList.contains(\"dropdown-menu\")) {\n        const e = t.closest(\".dropdown\");\n        e && U.find(\".dropdown-toggle\", e).forEach(t => t.classList.add(\"active\")), t.setAttribute(\"aria-expanded\", !0);\n      }\n\n      i && i();\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = ni.getOrCreateInstance(this);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t]();\n        }\n      });\n    }\n\n  }\n\n  P.on(document, \"click.bs.tab.data-api\", '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]', function (t) {\n    [\"A\", \"AREA\"].includes(this.tagName) && t.preventDefault(), l(this) || ni.getOrCreateInstance(this).show();\n  }), m(ni);\n  const si = {\n    animation: \"boolean\",\n    autohide: \"boolean\",\n    delay: \"number\"\n  },\n        oi = {\n    animation: !0,\n    autohide: !0,\n    delay: 5e3\n  };\n\n  class ri extends H {\n    constructor(t, e) {\n      super(t), this._config = this._getConfig(e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners();\n    }\n\n    static get DefaultType() {\n      return si;\n    }\n\n    static get Default() {\n      return oi;\n    }\n\n    static get NAME() {\n      return \"toast\";\n    }\n\n    show() {\n      P.trigger(this._element, \"show.bs.toast\").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add(\"fade\"), this._element.classList.remove(\"hide\"), d(this._element), this._element.classList.add(\"show\"), this._element.classList.add(\"showing\"), this._queueCallback(() => {\n        this._element.classList.remove(\"showing\"), P.trigger(this._element, \"shown.bs.toast\"), this._maybeScheduleHide();\n      }, this._element, this._config.animation));\n    }\n\n    hide() {\n      this._element.classList.contains(\"show\") && (P.trigger(this._element, \"hide.bs.toast\").defaultPrevented || (this._element.classList.add(\"showing\"), this._queueCallback(() => {\n        this._element.classList.add(\"hide\"), this._element.classList.remove(\"showing\"), this._element.classList.remove(\"show\"), P.trigger(this._element, \"hidden.bs.toast\");\n      }, this._element, this._config.animation)));\n    }\n\n    dispose() {\n      this._clearTimeout(), this._element.classList.contains(\"show\") && this._element.classList.remove(\"show\"), super.dispose();\n    }\n\n    _getConfig(t) {\n      return t = { ...oi,\n        ...F.getDataAttributes(this._element),\n        ...(\"object\" == typeof t && t ? t : {})\n      }, r(\"toast\", t, this.constructor.DefaultType), t;\n    }\n\n    _maybeScheduleHide() {\n      this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {\n        this.hide();\n      }, this._config.delay)));\n    }\n\n    _onInteraction(t, e) {\n      switch (t.type) {\n        case \"mouseover\":\n        case \"mouseout\":\n          this._hasMouseInteraction = e;\n          break;\n\n        case \"focusin\":\n        case \"focusout\":\n          this._hasKeyboardInteraction = e;\n      }\n\n      if (e) return void this._clearTimeout();\n      const i = t.relatedTarget;\n      this._element === i || this._element.contains(i) || this._maybeScheduleHide();\n    }\n\n    _setListeners() {\n      P.on(this._element, \"mouseover.bs.toast\", t => this._onInteraction(t, !0)), P.on(this._element, \"mouseout.bs.toast\", t => this._onInteraction(t, !1)), P.on(this._element, \"focusin.bs.toast\", t => this._onInteraction(t, !0)), P.on(this._element, \"focusout.bs.toast\", t => this._onInteraction(t, !1));\n    }\n\n    _clearTimeout() {\n      clearTimeout(this._timeout), this._timeout = null;\n    }\n\n    static jQueryInterface(t) {\n      return this.each(function () {\n        const e = ri.getOrCreateInstance(this, t);\n\n        if (\"string\" == typeof t) {\n          if (void 0 === e[t]) throw new TypeError(`No method named \"${t}\"`);\n          e[t](this);\n        }\n      });\n    }\n\n  }\n\n  return B(ri), m(ri), {\n    Alert: R,\n    Button: W,\n    Carousel: Z,\n    Collapse: et,\n    Dropdown: Te,\n    Modal: Pe,\n    Offcanvas: He,\n    Popover: Ze,\n    ScrollSpy: ii,\n    Tab: ni,\n    Toast: ri,\n    Tooltip: Xe\n  };\n});","map":null,"metadata":{},"sourceType":"script"}