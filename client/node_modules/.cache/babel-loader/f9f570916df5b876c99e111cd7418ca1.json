{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n    return function (set) {\n      var number = generateUniqueNumber(set);\n      set.add(number);\n      return number;\n    };\n  };\n\n  var createCache = function createCache(lastNumberWeakMap) {\n    return function (collection, nextNumber) {\n      lastNumberWeakMap.set(collection, nextNumber);\n      return nextNumber;\n    };\n  };\n  /*\n   * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n   * is fairly new.\n   */\n\n\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n  var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n  var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n\n  var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n    return function (collection) {\n      var lastNumber = lastNumberWeakMap.get(collection);\n      /*\n       * Let's try the cheapest algorithm first. It might fail to produce a new\n       * number, but it is so cheap that it is okay to take the risk. Just\n       * increase the last number by one or reset it to 0 if we reached the upper\n       * bound of SMIs (which stands for small integers). When the last number is\n       * unknown it is assumed that the collection contains zero based consecutive\n       * numbers.\n       */\n\n      var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n      if (!collection.has(nextNumber)) {\n        return cache(collection, nextNumber);\n      }\n      /*\n       * If there are less than half of 2 ** 30 numbers stored in the collection,\n       * the chance to generate a new random number in the range from 0 to 2 ** 30\n       * is at least 50%. It's benifitial to use only SMIs because they perform\n       * much better in any environment based on V8.\n       */\n\n\n      if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n        }\n\n        return cache(collection, nextNumber);\n      } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n      if (collection.size > MAX_SAFE_INTEGER) {\n        throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n      } // Otherwise use the full scale of safely usable integers.\n\n\n      while (collection.has(nextNumber)) {\n        nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n      }\n\n      return cache(collection, nextNumber);\n    };\n  };\n\n  var LAST_NUMBER_WEAK_MAP = new WeakMap();\n  var cache = createCache(LAST_NUMBER_WEAK_MAP);\n  var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n  var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n  exports.addUniqueNumber = addUniqueNumber;\n  exports.generateUniqueNumber = generateUniqueNumber;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["/Users/albert/projects/med-bakery-react/client/node_modules/fast-unique-numbers/build/es5/bundle.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","fastUniqueNumbers","createAddUniqueNumber","generateUniqueNumber","set","number","add","createCache","lastNumberWeakMap","collection","nextNumber","MAX_SAFE_INTEGER","Number","undefined","TWO_TO_THE_POWER_OF_TWENTY_NINE","TWO_TO_THE_POWER_OF_THIRTY","createGenerateUniqueNumber","cache","lastNumber","get","size","has","Math","floor","random","Error","LAST_NUMBER_WEAK_MAP","WeakMap","addUniqueNumber","Object","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.fastUniqueNumbers = {}));\n})(this, (function (exports) { 'use strict';\n\n    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {\n      return function (set) {\n        var number = generateUniqueNumber(set);\n        set.add(number);\n        return number;\n      };\n    };\n\n    var createCache = function createCache(lastNumberWeakMap) {\n      return function (collection, nextNumber) {\n        lastNumberWeakMap.set(collection, nextNumber);\n        return nextNumber;\n      };\n    };\n\n    /*\n     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n     * is fairly new.\n     */\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\n    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\n    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {\n      return function (collection) {\n        var lastNumber = lastNumberWeakMap.get(collection);\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n\n        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n        if (!collection.has(nextNumber)) {\n          return cache(collection, nextNumber);\n        }\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n\n\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n          while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n          }\n\n          return cache(collection, nextNumber);\n        } // Quickly check if there is a theoretical chance to generate a new number.\n\n\n        if (collection.size > MAX_SAFE_INTEGER) {\n          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        } // Otherwise use the full scale of safely usable integers.\n\n\n        while (collection.has(nextNumber)) {\n          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n      };\n    };\n\n    var LAST_NUMBER_WEAK_MAP = new WeakMap();\n    var cache = createCache(LAST_NUMBER_WEAK_MAP);\n    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\n    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\n    exports.addUniqueNumber = addUniqueNumber;\n    exports.generateUniqueNumber = generateUniqueNumber;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]},"metadata":{},"sourceType":"script"}